"use strict";(self.webpackChunkwoodpecker=self.webpackChunkwoodpecker||[]).push([[3671],{82006:e=>{e.exports=JSON.parse('[{"name":"Git Clone","url":"https://github.com/woodpecker-ci/plugin-git","icon":"https://woodpecker-ci.org/img/logo.svg","description":"This is the default plugin for the clone step.","docs":"<h1>plugin-git</h1>\\n<p>This plugin is automatically introduced into your pipeline as the first step.\\nIts purpose is to clone your Git repository.</p>\\n<h2>Features</h2>\\n<ul>\\n<li>Git LFS support is enabled by default.</li>\\n<li>Fetch tags when needed.</li>\\n<li>Ajust submodules.</li>\\n</ul>\\n<h2>Overriding Settings</h2>\\n<p>You can manually define your <code>clone</code> step in order to change plugin or override some of the default settings.\\nConsult <a href=\\"https://woodpecker-ci.org/docs/usage/workflow-syntax#clone\\">the <code>clone</code> section of the pipeline documentation</a> for more information;\\nthis documentation page only describes this plugin.</p>\\n<pre><code class=\\"language-yaml\\">clone:\\n  git:\\n    image: woodpeckerci/plugin-git\\n    settings:\\n      depth: 50\\n      lfs: false\\n</code></pre>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>depth</code></td>\\n<td><em>none</em></td>\\n<td>If specified, uses git\'s <code>--depth</code> option to create a shallow clone with a limited number of commits, overwritten by partial</td>\\n</tr>\\n<tr>\\n<td><code>lfs</code></td>\\n<td><code>true</code></td>\\n<td>Set this to <code>false</code> to disable retrieval of LFS files</td>\\n</tr>\\n<tr>\\n<td><code>recursive</code></td>\\n<td><code>false</code></td>\\n<td>Clones submodules recursively</td>\\n</tr>\\n<tr>\\n<td><code>skip_verify</code></td>\\n<td><code>false</code></td>\\n<td>Skips the SSL verification</td>\\n</tr>\\n<tr>\\n<td><code>tags</code></td>\\n<td><code>false</code> (except on tag event)</td>\\n<td>Fetches tags when set to true, default is false if event is not tag else true</td>\\n</tr>\\n<tr>\\n<td><code>submodule_overrides</code></td>\\n<td><em>none</em></td>\\n<td>Override submodule urls</td>\\n</tr>\\n<tr>\\n<td><code>submodule_update_remote</code></td>\\n<td><code>false</code></td>\\n<td>Pass the --remote flag to git submodule update</td>\\n</tr>\\n<tr>\\n<td><code>submodule_partial</code></td>\\n<td><code>true</code></td>\\n<td>Update submodules via partial clone (depth=1)</td>\\n</tr>\\n<tr>\\n<td><code>custom_ssl_path</code></td>\\n<td><em>none</em></td>\\n<td>Set path to custom cert</td>\\n</tr>\\n<tr>\\n<td><code>custom_ssl_url</code></td>\\n<td><em>none</em></td>\\n<td>Set url to custom cert</td>\\n</tr>\\n<tr>\\n<td><code>backoff</code></td>\\n<td><code>5sec</code></td>\\n<td>Change backoff duration</td>\\n</tr>\\n<tr>\\n<td><code>attempts</code></td>\\n<td><code>5</code></td>\\n<td>Change backoff attempts</td>\\n</tr>\\n<tr>\\n<td><code>branch</code></td>\\n<td>$CI_COMMIT_BRANCH</td>\\n<td>Change branch name to checkout to</td>\\n</tr>\\n<tr>\\n<td><code>partial</code></td>\\n<td><code>true</code> (except if tags are fetched)</td>\\n<td>Only fetch the one commit and it\'s blob objects to resolve all files, overwrite depth with 1</td>\\n</tr>\\n<tr>\\n<td><code>home</code></td>\\n<td></td>\\n<td>Change HOME var for commands executed, fail if it does not exist</td>\\n</tr>\\n<tr>\\n<td><code>remote</code></td>\\n<td>$CI_REPO_CLONE_URL</td>\\n<td>Set the git remote url</td>\\n</tr>\\n<tr>\\n<td><code>remote_ssh</code></td>\\n<td>$CI_REPO_CLONE_SSH_URL</td>\\n<td>Set the git SSH remote url</td>\\n</tr>\\n<tr>\\n<td><code>sha</code></td>\\n<td>$CI_COMMIT_SHA</td>\\n<td>git commit hash to retrieve (use <code>sha: \'\'</code> to clone the <code>ref</code>)</td>\\n</tr>\\n<tr>\\n<td><code>ref</code></td>\\n<td>$CI_COMMIT_REF</td>\\n<td>Set the git reference to retrieve (use <code>ref: refs/heads/a_branch</code> and <code>sha: \'\'</code> to retrieve the head commit from the \\"a_branch\\" branch)</td>\\n</tr>\\n<tr>\\n<td><code>path</code></td>\\n<td>$CI_WORKSPACE</td>\\n<td>Set destination path to clone to</td>\\n</tr>\\n<tr>\\n<td><code>use_ssh</code></td>\\n<td><code>false</code></td>\\n<td>Clone using SSH</td>\\n</tr>\\n<tr>\\n<td><code>ssh_key</code></td>\\n<td><em>none</em></td>\\n<td>SSH key for SSH clone</td>\\n</tr>\\n</tbody></table>\\n","tags":["git","clone"],"containerImage":"woodpeckerci/plugin-git","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-git","verified":true},{"name":"Docker Buildx","url":"https://codeberg.org/woodpecker-plugins/docker-buildx","icon":"https://woodpecker-ci.org/img/logo.svg","description":"plugin to build multiarch Docker images with buildx","docs":"<p>Woodpecker CI plugin to build multiarch Docker images with buildx. This plugin is a fork of <a href=\\"https://github.com/thegeeklab/drone-docker-buildx/\\">thegeeklab/drone-docker-buildx</a> which itself is a fork of <a href=\\"https://github.com/drone-plugins/drone-docker\\">drone-plugins/drone-docker</a>.</p>\\n<h2>Features</h2>\\n<ul>\\n<li>Build without push</li>\\n<li>Use custom registries</li>\\n<li>Build based on existing tags when needed</li>\\n<li>Push to multiple registries/repos</li>\\n</ul>\\n<p>It will automatically generate buildkit configuration to use custom CA certificate if following conditions are met:</p>\\n<ul>\\n<li>Setting <code>buildkit_config</code> is not set</li>\\n<li>Custom <code>registry</code>/<code>logins</code> value is provided</li>\\n<li>File exists <code>/etc/docker/certs.d/&lt;registry-value&gt;/ca.crt</code></li>\\n</ul>\\n<blockquote>\\n<p>NB! To mount custom CA you can use Woodpecker CI runner configuration environment <code>WOODPECKER_BACKEND_DOCKER_VOLUMES</code> with value <code>/etc/ssl/certs:/etc/ssl/certs:ro,/etc/docker/certs.d:/etc/docker/certs.d:ro</code>. And have created file <code>/etc/docker/certs.d/&lt;registry-value&gt;/ca.crt</code> with CA certificate on runner server host.</p>\\n</blockquote>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>dry-run</code></td>\\n<td><code>false</code></td>\\n<td>disables docker push</td>\\n</tr>\\n<tr>\\n<td><code>repo</code></td>\\n<td><em>none</em></td>\\n<td>sets repository name for the image (can be a list)</td>\\n</tr>\\n<tr>\\n<td><code>username</code></td>\\n<td><em>none</em></td>\\n<td>sets username to authenticates with</td>\\n</tr>\\n<tr>\\n<td><code>password</code></td>\\n<td><em>none</em></td>\\n<td>sets password / token to authenticates with</td>\\n</tr>\\n<tr>\\n<td><code>aws_access_key_id</code></td>\\n<td><em>none</em></td>\\n<td>sets AWS_ACCESS_KEY_ID for AWS ECR auth</td>\\n</tr>\\n<tr>\\n<td><code>aws_secret_access_key</code></td>\\n<td><em>none</em></td>\\n<td>sets AWS_SECRET_ACCESS_KEY for AWS ECR auth</td>\\n</tr>\\n<tr>\\n<td><code>aws_region</code></td>\\n<td><code>us-east-1</code></td>\\n<td>sets AWS_DEFAULT_REGION for AWS ECR auth</td>\\n</tr>\\n<tr>\\n<td><code>password</code></td>\\n<td><em>none</em></td>\\n<td>sets password / token to authenticates with</td>\\n</tr>\\n<tr>\\n<td><code>email</code></td>\\n<td><em>none</em></td>\\n<td>sets email address to authenticates with</td>\\n</tr>\\n<tr>\\n<td><code>registry</code></td>\\n<td><code>https://index.docker.io/v1/</code></td>\\n<td>sets docker registry to authenticate with</td>\\n</tr>\\n<tr>\\n<td><code>dockerfile</code></td>\\n<td><code>Dockerfile</code></td>\\n<td>sets dockerfile to use for the image build</td>\\n</tr>\\n<tr>\\n<td><code>tag</code>/<code>tags</code></td>\\n<td><em>none</em></td>\\n<td>sets repository tags to use for the image</td>\\n</tr>\\n<tr>\\n<td><code>platforms</code></td>\\n<td><em>none</em></td>\\n<td>sets target platform for build</td>\\n</tr>\\n</tbody></table>\\n<h2>auto_tag</h2>\\n<p>If set to true, it will use the <code>default_tag</code> (\\"latest\\") on tag event or default branch.\\nIf it\'s a tag event it will also assume sem versioning and add tags accordingly (<code>x</code>, <code>x.x</code> and <code>x.x.x</code>).\\nIf it\'s not a tag event, and no default branch, automated tags are skipped.</p>\\n<h2>Examples</h2>\\n<pre><code class=\\"language-yaml\\">publish-next-agent:\\n  image: woodpeckerci/plugin-docker-buildx\\n  secrets: [docker_username, docker_password]\\n  settings:\\n    repo: woodpeckerci/woodpecker-agent\\n    dockerfile: docker/Dockerfile.agent.multiarch\\n    platforms: windows/amd64,darwin/amd64,darwin/arm64,freebsd/amd64,linux/amd64,linux/arm64/v8\\n    tag: next\\n  when:\\n    branch: ${CI_REPO_DEFAULT_BRANCH}\\n    event: push\\n</code></pre>\\n<pre><code class=\\"language-yaml\\">publish:\\n  image: woodpeckerci/plugin-docker-buildx\\n  settings:\\n    platforms: linux/386,linux/amd64,linux/arm/v6,linux/arm64/v8,linux/ppc64le,linux/riscv64,linux/s390x\\n    repo: codeberg.org/${CI_REPO_OWNER}/hello\\n    registry: codeberg.org\\n    tags: latest\\n    username: ${CI_REPO_OWNER}\\n    password:\\n      from_secret: cb_token\\n</code></pre>\\n<pre><code class=\\"language-yaml\\">docker-build:\\n  image: woodpeckerci/plugin-docker-buildx\\n  settings:\\n    repo: codeberg.org/${CI_REPO_OWNER}/hello\\n    registry: codeberg.org\\n    dry_run: true\\n    output: type=oci,dest=${CI_REPO_OWNER}-hello.tar\\n</code></pre>\\n<h2>Advanced Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>mirror</code></td>\\n<td><em>none</em></td>\\n<td>sets a registry mirror to pull images</td>\\n</tr>\\n<tr>\\n<td><code>storage_driver</code></td>\\n<td><em>none</em></td>\\n<td>sets the docker daemon storage driver</td>\\n</tr>\\n<tr>\\n<td><code>storage_path</code></td>\\n<td><code>/var/lib/docker</code></td>\\n<td>sets the docker daemon storage path</td>\\n</tr>\\n<tr>\\n<td><code>bip</code></td>\\n<td><em>none</em></td>\\n<td>allows the docker daemon to bride ip address</td>\\n</tr>\\n<tr>\\n<td><code>mtu</code></td>\\n<td><em>none</em></td>\\n<td>sets docker daemon custom mtu setting</td>\\n</tr>\\n<tr>\\n<td><code>custom_dns</code></td>\\n<td><em>none</em></td>\\n<td>sets custom docker daemon dns server</td>\\n</tr>\\n<tr>\\n<td><code>custom_dns_search</code></td>\\n<td><em>none</em></td>\\n<td>sets custom docker daemon dns search domain</td>\\n</tr>\\n<tr>\\n<td><code>insecure</code></td>\\n<td><code>false</code></td>\\n<td>allows the docker daemon to use insecure registries</td>\\n</tr>\\n<tr>\\n<td><code>ipv6</code></td>\\n<td><code>false</code></td>\\n<td>enables docker daemon IPv6 support</td>\\n</tr>\\n<tr>\\n<td><code>experimental</code></td>\\n<td><code>false</code></td>\\n<td>enables docker daemon experimental mode</td>\\n</tr>\\n<tr>\\n<td><code>debug</code></td>\\n<td><code>false</code></td>\\n<td>enables verbose debug mode for the docker daemon</td>\\n</tr>\\n<tr>\\n<td><code>daemon_off</code></td>\\n<td><code>false</code></td>\\n<td>disables the startup of the docker daemon</td>\\n</tr>\\n<tr>\\n<td><code>buildkit_config</code></td>\\n<td><em>none</em></td>\\n<td>sets content of the docker <a href=\\"https://github.com/moby/buildkit/blob/master/docs/buildkitd.toml.md\\">buildkit TOML config</a></td>\\n</tr>\\n<tr>\\n<td><code>buildkit_driveropt</code></td>\\n<td><em>none</em></td>\\n<td>adds one or multiple <code>--driver-opt</code> buildx arguments for the default buildkit builder instance</td>\\n</tr>\\n<tr>\\n<td><code>tags_file</code></td>\\n<td><em>none</em></td>\\n<td>overrides the <code>tags</code> option with values in a file named <code>.tags</code>; multiple tags can be specified separated by a newline</td>\\n</tr>\\n<tr>\\n<td><code>context</code></td>\\n<td><code>.</code></td>\\n<td>sets the path of the build context to use</td>\\n</tr>\\n<tr>\\n<td><code>auto_tag</code></td>\\n<td><code>false</code></td>\\n<td>generates tag names automatically based on git branch and git tag, tags supplied via <code>tags</code> are additionally added to the auto_tags without suffix</td>\\n</tr>\\n<tr>\\n<td><code>default_suffix\\"</code>/<code>auto_tag_suffix</code></td>\\n<td><em>none</em></td>\\n<td>generates tag names with the given suffix</td>\\n</tr>\\n<tr>\\n<td><code>default_tag</code></td>\\n<td><code>latest</code></td>\\n<td>overrides the default tag name used when generating with <code>auto_tag</code> enabled</td>\\n</tr>\\n<tr>\\n<td><code>label</code>/<code>labels</code></td>\\n<td><em>none</em></td>\\n<td>sets labels to use for the image in format <code>&lt;name&gt;=&lt;value&gt;</code></td>\\n</tr>\\n<tr>\\n<td><code>default_labels</code>/<code>auto_labels</code></td>\\n<td><code>true</code></td>\\n<td>sets docker image labels based on git information</td>\\n</tr>\\n<tr>\\n<td><code>build_args</code></td>\\n<td><em>none</em></td>\\n<td>sets custom build arguments for the build</td>\\n</tr>\\n<tr>\\n<td><code>build_args_from_env</code></td>\\n<td><em>none</em></td>\\n<td>forwards environment variables as custom arguments to the build</td>\\n</tr>\\n<tr>\\n<td><code>quiet</code></td>\\n<td><code>false</code></td>\\n<td>enables suppression of the build output</td>\\n</tr>\\n<tr>\\n<td><code>target</code></td>\\n<td><em>none</em></td>\\n<td>sets the build target to use</td>\\n</tr>\\n<tr>\\n<td><code>cache_from</code></td>\\n<td><em>none</em></td>\\n<td>sets images to consider as cache sources</td>\\n</tr>\\n<tr>\\n<td><code>pull_image</code></td>\\n<td><code>true</code></td>\\n<td>enforces to pull base image at build time</td>\\n</tr>\\n<tr>\\n<td><code>compress</code></td>\\n<td><code>false</code></td>\\n<td>enables compression of the build context using gzip</td>\\n</tr>\\n<tr>\\n<td><code>config</code></td>\\n<td><em>none</em></td>\\n<td>sets content of the docker daemon json config</td>\\n</tr>\\n<tr>\\n<td><code>purge</code></td>\\n<td><code>true</code></td>\\n<td>enables cleanup of the docker environment at the end of a build</td>\\n</tr>\\n<tr>\\n<td><code>no_cache</code></td>\\n<td><code>false</code></td>\\n<td>disables the usage of cached intermediate containers</td>\\n</tr>\\n<tr>\\n<td><code>add_host</code></td>\\n<td><em>none</em></td>\\n<td>sets additional host:ip mapping</td>\\n</tr>\\n<tr>\\n<td><code>output</code></td>\\n<td><em>none</em></td>\\n<td>sets build output in format <code>type=&lt;type&gt;[,&lt;key&gt;=&lt;value&gt;]</code></td>\\n</tr>\\n<tr>\\n<td><code>logins</code></td>\\n<td><em>none</em></td>\\n<td>option to log into multiple registries</td>\\n</tr>\\n<tr>\\n<td><code>env_file</code></td>\\n<td><em>none</em></td>\\n<td>load env vars from specified file</td>\\n</tr>\\n<tr>\\n<td><code>ecr_create_repository</code></td>\\n<td><code>false</code></td>\\n<td>creates the ECR repository if it does not exist</td>\\n</tr>\\n<tr>\\n<td><code>ecr_lifecycle_policy</code></td>\\n<td><em>none</em></td>\\n<td>AWS ECR lifecycle policy</td>\\n</tr>\\n<tr>\\n<td><code>ecr_repository_policy</code></td>\\n<td><em>none</em></td>\\n<td>AWS ECR repository policy</td>\\n</tr>\\n<tr>\\n<td><code>ecr_scan_on_push</code></td>\\n<td><em>none</em></td>\\n<td>AWS: whether to enable image scanning on push</td>\\n</tr>\\n</tbody></table>\\n<h2>Multi registry push example</h2>\\n<p>Only supported with <code>woodpecker &gt;= 1.0.0</code> (next-da997fa3).</p>\\n<pre><code class=\\"language-yaml\\">settings:\\n  repo: a6543/tmp,codeberg.org/6543/tmp\\n  tag: demo\\n  logins:\\n    - registry: https://index.docker.io/v1/\\n      username: a6543\\n      password:\\n        from_secret: docker_token\\n    - registry: https://codeberg.org\\n      username: \\"6543\\"\\n      password:\\n        from_secret: cb_token\\n    - registry: https://&lt;account-id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com\\n      aws_region: &lt;region&gt;\\n      aws_access_key_id:\\n        from_secret: aws_access_key_id\\n      aws_secret_access_key:\\n        from_secret: aws_secret_access_key\\n</code></pre>\\n<h2>Using <code>plugin-docker-buildx</code> behind a proxy</h2>\\n<p>When performing a docker build behind a corporate proxy one needs to pass through the proxy settings to the plugin.</p>\\n<pre><code class=\\"language-yaml\\">variables:\\n  # proxy config\\n  - proxy_conf: &amp;proxy_conf\\n      - http_proxy: \\"http://X.Y.Z.Z:3128\\"\\n      - https_proxy: \\"http://X.Y.Z.Z:3128\\"\\n      - no_proxy: \\".my-subdomain.com\\"\\n  # deployment targets\\n  - &amp;publish_repos \\"codeberg.org/test\\"\\n  # logins for deployment targets\\n  - publish_logins: &amp;publish_logins\\n      - registry: https://codeberg.org\\n        username:\\n          from_secret: CODEBERG_USER\\n        password:\\n          from_secret: CODEBERG_TOKEN\\n\\nsteps:\\n  test:\\n    image: woodpeckerci/plugin-docker-buildx:2\\n    environment:\\n      # adding proxy in env for the plugin runtime itself.\\n      - &lt;&lt;: *proxy_conf\\n    privileged: true\\n    settings:\\n      dry_run: true\\n      repo: *publish_repos\\n      dockerfile: Dockerfile.multi\\n      platforms: linux/amd64\\n      auto_tag: true\\n      logins: *publish_logins\\n      # Adding custom dns server to lookup internal Docker Hub mirror.\\n      # custom_dns:\\n      #   - 192.168.55.31\\n      #   - 192.168.55.32\\n      # Adding an optional Docker Hub mirror for the nested dockerd.\\n      # mirror: https://my-mirror.example.com\\n      build_args:\\n        # passthrough proxy config to the build process and Dockerfile CMDs itself.\\n        - &lt;&lt;: *proxy_conf\\n      # add driver-opt http config to tell buildkit + buildx to resolve external checksums through a proxy.\\n      buildkit_driveropt:\\n        - \\"env.http_proxy=http://X.Y.Z.Z:3128\\"\\n        - \\"env.https_proxy=http://X.Y.Z.Z:3128\\"\\n        - \\"env.no_proxy=.my-subdomain.com\\"\\n</code></pre>\\n","tags":["docker","image","container","build"],"containerImage":"woodpeckerci/plugin-docker-buildx","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-docker-buildx","verified":true},{"name":"Codecov","url":"https://github.com/woodpecker-ci/plugin-codecov","icon":"https://woodpecker-ci.org/img/logo.svg","description":"Plugin to upload coverage reports to Codecov.io.","docs":"<p>The Codecov plugin uploads coverage reports in one of the <a href=\\"https://docs.codecov.com/docs/supported-report-formats\\">supported formats</a> to <a href=\\"https://about.codecov.io/\\">Codecov.io</a>.</p>\\n<h2>Usage</h2>\\n<p>To use the plugin add a step similar to the following one to your Woodpecker pipeline config:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  codecov:\\n    image: woodpeckerci/plugin-codecov\\n    settings:\\n      files:\\n        - my-coverage-report-output.out\\n        - another-coverage-report.json\\n      token:\\n        from_secret: codecov_token\\n</code></pre>\\n","tags":["coverage","testing"],"containerImage":"woodpeckerci/plugin-codecov","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-codecov","verified":true},{"name":"Surge preview plugin","url":"https://github.com/woodpecker-ci/plugin-surge-preview","icon":"https://woodpecker-ci.org/img/logo.svg","description":"Plugin to create static pages deployments as preview environments on pull-requests.","docs":"<h1>plugin-surge-preview</h1>\\n<p>The surge-preview plugin uploads a files of a directory to the CDN of <a href=\\"https://surge.sh/\\">surge.sh</a> it automatically generates an url and posts the status of the deployment with an url as a comment to the pull-request. After closing a pull-request it automatically destroys the preview environment again.</p>\\n<h2>Usage</h2>\\n<p>To use the plugin add a step similar to the following one to your Woodpecker pipeline config:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  preview:\\n    image: woodpeckerci/plugin-surge-preview\\n    settings:\\n      path: dist/ # path to directory to publish files from\\n      surge_token: xxx # install surge cli and run `surge token`: https://surge.sh/help/getting-started-with-surge\\n      forge_type: github # or gitea, gitlab, ...\\n      forge_url: https://github.com # or https://codeberg.org, https://gitlab.com, ...\\n      forge_repo_token: xxx # access token for your forge\\n    when:\\n      event: pull_request\\n</code></pre>\\n","tags":["publish","cdn","preview"],"containerImage":"woodpeckerci/plugin-surge-preview","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-surge-preview","verified":true},{"name":"S3 Plugin","url":"https://github.com/woodpecker-ci/plugin-s3","icon":"https://woodpecker-ci.org/img/logo.svg","description":"Plugin to publish files and artifacts to Amazon S3 or Minio.","docs":"<h1>S3 Plugin</h1>\\n<p>The S3 plugin uploads files and build artifacts to your S3 bucket, or S3-compatible bucket such as Minio.\\nThe below pipeline configuration demonstrates simple usage:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  upload:\\n    image: woodpeckerci/plugin-s3\\n    settings:\\n      bucket: my-bucket-name\\n      access_key: a50d28f4dd477bc184fbd10b376de753\\n      secret_key: ****************************************\\n      source: public/**/*\\n      target: /target/location\\n</code></pre>\\n<p>Source the aws credentials from secrets:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  upload:\\n    image: woodpeckerci/plugin-s3\\n    settings:\\n      bucket: my-bucket-name\\n      access_key:\\n        from_secret: aws_access_key_id\\n      secret_key:\\n        from_secret: aws_secret_access_key\\n      source: public/**/*\\n      target: /target/location\\n</code></pre>\\n<p>Use the build number in the S3 target prefix:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  upload:\\n    image: woodpeckerci/plugin-s3\\n    settings:\\n      bucket: my-bucket-name\\n      source: public/**/*\\n      target: /target/location/${CI_BUILD_NUMBER}\\n</code></pre>\\n<p>Override the default acl and region:</p>\\n<pre><code class=\\"language-yml\\">steps:\\n- name: upload\\n  image: woodpeckerci/plugin-s3\\n  settings:\\n    bucket: my-bucket-name\\n    acl: public-read\\n    region: us-east-1\\n    source: public/**/*\\n    target: /target/location\\n</code></pre>\\n<p>Configure the plugin to strip path prefixes when uploading:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  upload:\\n    image: woodpeckerci/plugin-s3\\n    settings:\\n      bucket: my-bucket-name\\n      source: public/**/*\\n      target: /target/location\\n      strip_prefix: public/\\n</code></pre>\\n<p>Configure the plugin to exclude files from upload:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  upload:\\n    image: woodpeckerci/plugin-s3\\n    settings:\\n      bucket: my-bucket-name\\n      source: public/**/*\\n      target: /target/location\\n      exclude:\\n        - **/*.xml\\n</code></pre>\\n<p>Configure the plugin to connect to a Minio server:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  upload:\\n    image: woodpeckerci/plugin-s3\\n    settings:\\n      bucket: my-bucket-name\\n      source: public/**/*\\n      target: /target/location\\n      path_style: true\\n      endpoint: https://play.minio.io:9000\\n</code></pre>\\n<h2>Parameter Reference</h2>\\n<p>endpoint\\n: custom endpoint URL (optional, to use a S3 compatible non-Amazon service)</p>\\n<p>access_key\\n: amazon key (optional)</p>\\n<p>secret_key\\n: amazon secret key (optional)</p>\\n<p>bucket\\n: bucket name</p>\\n<p>region\\n: bucket region (<code>us-east-1</code>, <code>eu-west-1</code>, etc)</p>\\n<p>acl\\n: access to files that are uploaded (<code>private</code>, <code>public-read</code>, etc)</p>\\n<p>source\\n: source location of the files, using a glob matching pattern. Location must be within the woodpecker workspace.</p>\\n<p>target\\n: target location of files in the bucket</p>\\n<p>encryption\\n: if provided, use server-side encryption</p>\\n<p>strip_prefix\\n: strip the prefix from source path</p>\\n<p>exclude\\n: glob exclusion patterns</p>\\n<p>path_style\\n: whether path style URLs should be used (true for minio)</p>\\n","tags":["publish","s3","amazon","minio","storage"],"containerImage":"woodpeckerci/plugin-s3","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-s3","verified":true},{"name":"Node PM","url":"https://codeberg.org/woodpecker-plugins/node-pm","icon":"https://codeberg.org/woodpecker-plugins/node-pm/media/branch/main/nodejs-logo-hexagon.png","description":"Execute NPM, PNPM or Yarn scripts","docs":"<h1>plugin-node-pm</h1>\\n<p>Woodpecker plugin to install <a href=\\"https://nodejs.org/en\\">Node.js\xae</a> dependencies and execute NPM, PNPM or Yarn scripts.</p>\\n<h2>Features</h2>\\n<ul>\\n<li>Automatically find used package manager (based on lockfile)</li>\\n<li>Install dependencies, if <code>node_modules</code> don\'t exist</li>\\n<li>Run multiple tasks</li>\\n</ul>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>run</code></td>\\n<td><em>none</em></td>\\n<td>Script name or YAML list of multiple script names to run (see <a href=\\"https://docs.npmjs.com/cli/v10/configuring-npm/package-json#scripts\\"><code>scripts</code> property in <code>package.json</code></a>)</td>\\n</tr>\\n<tr>\\n<td><code>with</code></td>\\n<td><em>autodetect</em>, fallback to <code>npm</code></td>\\n<td>Enforce to use either <code>npm</code>, <code>yarn</code> or <code>pnpm</code> as the package manager</td>\\n</tr>\\n<tr>\\n<td><code>frozen_lockfile</code></td>\\n<td><code>false</code></td>\\n<td>If set to <code>true</code> (<em>recommended</em>): fails if lockfile is invalid, missing or outdated</td>\\n</tr>\\n<tr>\\n<td><code>ignore_node_modules</code></td>\\n<td><code>false</code></td>\\n<td>If set to <code>true</code> (<em>recommended</em>): run dependencies install even with existing <code>node_modules</code> directory</td>\\n</tr>\\n</tbody></table>\\n<h2>Examples</h2>\\n<p>Workflow running one script:</p>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n  build:\\n    image: codeberg.org/woodpecker-plugins/node-pm\\n    settings:\\n      run: build # script name\\n      with: pnpm # if `with` is set, enforce to use this package manager\\n      frozen_lockfile: true # recommended\\n      ignore_node_modules: true # recommended\\n</code></pre>\\n<p>Workflow running multiple scripts (<code>prepare</code> and <code>build</code>):</p>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n  build:\\n    image: codeberg.org/woodpecker-plugins/node-pm\\n    settings:\\n      run:\\n        - prepare\\n        - build\\n</code></pre>\\n","tags":["node","npm","pnpm","yarn"],"containerImage":"woodpeckerci/plugin-node-pm","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-node-pm","verified":true},{"name":"Prettier","url":"https://github.com/woodpecker-ci/plugin-prettier","icon":"https://raw.githubusercontent.com/woodpecker-ci/plugin-prettier/main/prettier.png","description":"This plugin can be used to check if a repository is following prettier rules.","docs":"<h1>plugin-prettier</h1>\\n<p>This plugin can be used to check if a repository is following <a href=\\"https://prettier.io/\\">prettier</a> rules.</p>\\n<h2>Sample</h2>\\n<pre><code class=\\"language-yaml\\">steps:\\n  prettier:\\n    image: woodpeckerci/plugin-prettier:next\\n</code></pre>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>path</code></td>\\n<td><code>.</code></td>\\n<td>If specified, it checks in a specified path</td>\\n</tr>\\n</tbody></table>\\n","tags":["lint","test","prettier"],"containerImage":"woodpeckerci/plugin-prettier","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-prettier","verified":true},{"name":"Extend env plugin","url":"https://github.com/woodpecker-ci/plugin-extend-env","icon":"https://woodpecker-ci.org/img/logo.svg","description":"Extend your .env file with additional variables like semver information.","docs":"<h1>plugin-extend-env</h1>\\n<p>The extend env plugin extends an existing or creates a new <code>.env</code> file with additional variables like semver information.</p>\\n<p>The below pipeline configuration demonstrates simple usage:</p>\\n<pre><code class=\\"language-yml\\">steps:\\n  extend-env:\\n    image: woodpeckerci/plugin-extend-env\\n</code></pre>\\n","tags":["env","semver"],"containerImage":"woodpeckerci/plugin-extend-env","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-extend-env","verified":true},{"name":"Block Git changes","url":"https://codeberg.org/qwerty287/woodpecker-block-git-changes","description":"Plugin to block uncommited  changes in the Git repository","docs":"<p>Plugin that fails if the Git repository contains any uncommited changes.</p>\\n<h2>Usage</h2>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n    block-changes:\\n        image: qwerty287/woodpecker-block-git-changes\\n</code></pre>\\n<p>This will never fail because there isn\'t any change done before.</p>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n    echo:\\n        image: alpine\\n        commands:\\n            - echo \\"hello world\\" &gt; README.md\\n\\n    block-changes:\\n      image: qwerty287/woodpecker-block-git-changes\\n</code></pre>\\n<p>This will fail if your README.md doesn\'t already contain <code>hello world</code>.</p>\\n","tags":["git","changes"],"containerImage":"qwerty287/woodpecker-block-git-changes","containerImageUrl":"https://hub.docker.com/r/qwerty287/woodpecker-block-git-changes","verified":false},{"name":"Regex Check","url":"https://codeberg.org/qwerty287/woodpecker-regex-check","description":"Plugin to check if files contain specified regex or match the wildcard","docs":"<p>Plugin to check if files contain specified regex or match the wildcard.</p>\\n<h2>Usage</h2>\\n<p>Example pipeline:</p>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n    find-static-imports:\\n        image: qwerty287/woodpecker-regex-check\\n        settings:\\n            pattern: \\"*.java\\"\\n            regex: \\"import static .*;\\"\\n</code></pre>\\n<h3>Config file</h3>\\n<p>With the <code>config</code> setting, you can set a path to the config file. This allows you to specify multiple rules. It can be a JSON or a YAML file, must be a list of items with the following options:</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Name</th>\\n<th>Description</th>\\n<th>Default</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>pattern</code></td>\\n<td>File pattern on which formatting should run</td>\\n<td><code>*</code> (all files)</td>\\n</tr>\\n<tr>\\n<td><code>path</code></td>\\n<td>Subdirectory of repository root to check</td>\\n<td><code>.</code> (repository root directory)</td>\\n</tr>\\n<tr>\\n<td><code>regex</code></td>\\n<td>Regex to search for</td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>glob</code></td>\\n<td>Wildcard to match file contents</td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>must_contain</code></td>\\n<td>If files must (if <code>true</code>) or must not (if <code>false</code>) contain the regex/wildcard</td>\\n<td><code>false</code></td>\\n</tr>\\n</tbody></table>\\n<p><code>regex</code> or <code>glob</code> is necessary, but you are not allowed to set both.</p>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Name</th>\\n<th>Description</th>\\n<th>Default</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>pattern</code></td>\\n<td>File pattern on which checks should run</td>\\n<td><code>*</code> (all files)</td>\\n</tr>\\n<tr>\\n<td><code>path</code></td>\\n<td>Subdirectory of repository root to check</td>\\n<td><code>.</code> (repository root directory)</td>\\n</tr>\\n<tr>\\n<td><code>regex</code></td>\\n<td>Regex to search for</td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>glob</code></td>\\n<td>Wildcard to match file contents</td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>config</code></td>\\n<td>Path to config file</td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>must_contain</code></td>\\n<td>If files must (if <code>true</code>) or must not (if <code>false</code>) contain the regex/wildcard</td>\\n<td><code>false</code></td>\\n</tr>\\n</tbody></table>\\n<p><code>regex</code>, <code>glob</code> or <code>config</code> is necessary, but you are not allowed to set both <code>regex</code> and <code>glob</code>.\\n<code>pattern</code> and <code>glob</code> use <a href=\\"https://github.com/gobwas/glob\\">https://github.com/gobwas/glob</a>.</p>\\n","tags":["regex","wildcard"],"containerImage":"qwerty287/woodpecker-regex-check","containerImageUrl":"https://hub.docker.com/r/qwerty287/woodpecker-regex-check","verified":false},{"name":"Gitea Create Pull Request","url":"https://codeberg.org/JohnWalkerx/gitea-pull-request-create-plugin","icon":"https://codeberg.org/forgejo/forgejo/raw/branch/forgejo/public/assets/img/svg/octicon-git-pull-request.svg","description":"Plugin to create a new pull request on a Gitea/Forgejo repo.","docs":"<p>Woodpecker CI plugin to create new pull requests on a Gitea/Forgejo repo.</p>\\n<p>It lets you create a new PR of a specified branch and can trigger an automerge of the PR.</p>\\n<p>If a PR for the specified branch already exists it skip the PR creation.\\nSo you can create workflows for e.g. update dependencies with a automated PR workflow.</p>\\n<p>You\'ll need to generate an Gitea/Forgejo API token for authentification.</p>\\n<p><strong>NOTE:</strong> The option <code>delete_branch_after_merge</code> doesn\'t work in combination with automerge due to <a href=\\"https://codeberg.org/forgejo/forgejo/issues/933\\">this issue</a> in Forgejo/Gitea. So the branch won\'t get deleted after a merge. On the next run it creates an empty PR because the branch still exists but with no diff to the main branch.</p>\\n<p>As a workaround for this issue the option <code>close_pr_if_empty</code> and <code>delete_branch_if_pr_empty</code> is useful.</p>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>gitea_address</td>\\n<td><em>none</em></td>\\n<td>Address of the Gitea/Forgejo instance</td>\\n</tr>\\n<tr>\\n<td>gitea_token</td>\\n<td><em>none</em></td>\\n<td>API token for authentification on Gitea/Forgejo instance</td>\\n</tr>\\n<tr>\\n<td>owner</td>\\n<td><em>none</em></td>\\n<td>Owner of the repo owner</td>\\n</tr>\\n<tr>\\n<td>repo</td>\\n<td><em>none</em></td>\\n<td>Repository name</td>\\n</tr>\\n<tr>\\n<td>branch</td>\\n<td><em>none</em></td>\\n<td>Branch name for which you wanna create a PR</td>\\n</tr>\\n<tr>\\n<td>base_branch</td>\\n<td><em>none</em></td>\\n<td>Name of the base branch you want to merge into</td>\\n</tr>\\n<tr>\\n<td>pr_title</td>\\n<td><em>none</em></td>\\n<td>Title of the PR</td>\\n</tr>\\n<tr>\\n<td>pr_body</td>\\n<td><em>none</em></td>\\n<td>Body content of the PR</td>\\n</tr>\\n<tr>\\n<td>skip_on_missing_branch</td>\\n<td><em>false</em></td>\\n<td>Skip PR creation if branch don\'t exist. Otherwise return with failure.</td>\\n</tr>\\n<tr>\\n<td>close_pr_if_empty</td>\\n<td><em>false</em></td>\\n<td>Close PR if there is no difference between branch and base_branch</td>\\n</tr>\\n<tr>\\n<td>delete_branch_if_pr_empty</td>\\n<td><em>false</em></td>\\n<td>Delete branch if there is no difference between branch und base_branch</td>\\n</tr>\\n<tr>\\n<td>merge_when_checks_succeed</td>\\n<td><em>false</em></td>\\n<td>Automerge branch when all specified checks succeeded successful</td>\\n</tr>\\n<tr>\\n<td>delete_branch_after_merge</td>\\n<td><em>false</em></td>\\n<td>Delete branch after PR got merged automatically</td>\\n</tr>\\n</tbody></table>\\n<h2>Example</h2>\\n<pre><code class=\\"language-yaml\\">steps:\\n  create-pr:\\n    image: johnwalkerx/gitea-pull-request-create-plugin:latest\\n    pull: true\\n    settings:\\n      gitea_address: https://codeberg.org\\n      gitea_token:\\n        from_secret: token\\n      owner: ${CI_REPO_OWNER}\\n      repo: ${CI_REPO_NAME}\\n      branch: ${CI_COMMIT_BRANCH}\\n      base_branch: main\\n      pr_title: My pull request title\\n      pr_body: PR automatically created by Woodpecker CI\\n      skip_on_missing_branch: true\\n      close_pr_if_empty: true\\n      delete_branch_if_pr_empty: true\\n      merge_when_checks_succeed: true\\n      delete_branch_after_merge: true\\n</code></pre>\\n","tags":["Gitea","PullRequest"],"containerImage":"johnwalkerx/gitea-pull-request-create-plugin","containerImageUrl":"https://hub.docker.com/r/johnwalkerx/gitea-pull-request-create-plugin","verified":false},{"name":"Gitea Comment","url":"https://github.com/markopolo123/gitea-comment-plugin","description":"Plugin to add comments to a Gitea Pull Request","docs":"<p>A Woodpecker plugin to post comments onto a Gitea Pull Request.</p>\\n<h2>Usage</h2>\\n<p>Example pipeline:</p>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n  comment:\\n    image: mcs94/gitea-comment\\n    settings:\\n      gitea_address: https://gitea.url.goes.here\\n      gitea_token:\\n        from_secret: gitea_token\\n      comment: &gt;\\n        \u2705 Build ${CI_BUILD_EVENT} of `${CI_REPO_NAME}` has status `${CI_BUILD_STATUS}`.\\n\\n        \ud83d\udcdd Commit by ${CI_COMMIT_AUTHOR} on `${CI_COMMIT_BRANCH}`:\\n\\n        `${CI_COMMIT_MESSAGE}`\\n\\n        \ud83c\udf10 ${CI_BUILD_LINK}\\n    when:\\n      event: [pull_request]\\n</code></pre>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Name</th>\\n<th>Description</th>\\n<th>Default</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>gitea_address</code></td>\\n<td>URL for your gitea instance</td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>gitea_token</code></td>\\n<td>Gitea API token</td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>comment</code></td>\\n<td>comment to add to Pull Request</td>\\n<td>none</td>\\n</tr>\\n</tbody></table>\\n","tags":["Gitea","comment"],"containerImage":"mcs94/gitea-comment","containerImageUrl":"https://hub.docker.com/r/mcs94/gitea-comment","verified":false},{"name":"Git Push","url":"https://github.com/appleboy/drone-git-push","icon":"https://raw.githubusercontent.com/appleboy/drone-git-push/master/images/logo.svg","description":"Commit and push to an git repo via SSH","docs":"<p>Use this plugin for commit and push an git repo.\\nYou will need to supply Drone / Woodpecker with a private SSH key or use the same credentials as the cloned repo to being able to push changes.</p>\\n<pre><code class=\\"language-yaml\\">- name: push commit\\n  image: appleboy/drone-git-push\\n  settings:\\n    branch: master\\n    remote: ssh://git@git.heroku.com/falling-wind-1624.git\\n    force: false\\n    commit: true\\n</code></pre>\\n<p>An example of pushing a branch back to the current repository:</p>\\n<pre><code class=\\"language-yaml\\">- name: push commit\\n  image: appleboy/drone-git-push\\n  settings:\\n    remote_name: origin\\n    branch: gh-pages\\n    local_ref: gh-pages\\n</code></pre>\\n<p>An example of specifying the path to a repo:</p>\\n<pre><code class=\\"language-yaml\\">- name: push commit\\n  image: appleboy/drone-git-push\\n  settings:\\n    remote_name: origin\\n    branch: gh-pages\\n    local_ref: gh-pages\\n    path: path/to/repo\\n</code></pre>\\n<h2>Parameter Reference</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>setting</th>\\n<th>description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>ssh_key</td>\\n<td>private SSH key for the remote machine (make sure it ends with a newline)</td>\\n</tr>\\n<tr>\\n<td>remote</td>\\n<td>target remote repository (if blank, assume exists)</td>\\n</tr>\\n<tr>\\n<td>remote_name</td>\\n<td>name of the remote to use locally (default \\"deploy\\")</td>\\n</tr>\\n<tr>\\n<td>branch</td>\\n<td>target remote branch, defaults to master</td>\\n</tr>\\n<tr>\\n<td>local_branch</td>\\n<td>local branch or ref to push (default \\"HEAD\\")</td>\\n</tr>\\n<tr>\\n<td>path</td>\\n<td>path to git repo (if blank, assume current directory)</td>\\n</tr>\\n<tr>\\n<td>force</td>\\n<td>force push using the <code>--force</code> flag, defaults to false</td>\\n</tr>\\n<tr>\\n<td>skip_verify</td>\\n<td>skip verification of HTTPS certs, defaults to false</td>\\n</tr>\\n<tr>\\n<td>commit</td>\\n<td>add and commit the contents of the repo before pushing, defaults to false</td>\\n</tr>\\n<tr>\\n<td>commit_message</td>\\n<td>add a custom message for commit, if it is omitted, it will be <code>[skip ci] Commit dirty state</code></td>\\n</tr>\\n<tr>\\n<td>empty_commit</td>\\n<td>if you only want generate an empty commit, you can do it using this option</td>\\n</tr>\\n<tr>\\n<td>tag</td>\\n<td>if you want to add a tag to the commit, you can do it using this option. You must also set <code>followtags</code> to <code>true</code> if you want the tag to be pushed to the remote</td>\\n</tr>\\n<tr>\\n<td>author_name</td>\\n<td>the name to use for the author of the commit (if blank, assume push commiter name)</td>\\n</tr>\\n<tr>\\n<td>author_email</td>\\n<td>the email address to use for the author of the commit (if blank, assume push commiter name)</td>\\n</tr>\\n<tr>\\n<td>followtags</td>\\n<td>push with --follow-tags option</td>\\n</tr>\\n<tr>\\n<td>rebase</td>\\n<td>pull --rebase before pushing</td>\\n</tr>\\n</tbody></table>\\n","tags":["deploy","publish","git-push"],"author":"appleboy","containerImage":"appleboy/drone-git-push","containerImageUrl":"https://hub.docker.com/r/appleboy/drone-git-push","verified":false},{"name":"WebDAV","url":"https://github.com/vividboarder/drone-webdav","description":"plugin to publish any artifacts to any WebDAV server","docs":"<p>A <a href=\\"https://www.drone.io/\\">Drone CI</a> / <a href=\\"https://woodpecker-ci.org/\\">Woodpecker CI</a> plugin,\\nthat will allow pushing build artifacts to any <a href=\\"http://www.webdav.org/\\">WebDAV</a> server, including Nextcloud or ownCloud.</p>\\n<h2>Features</h2>\\n<ul>\\n<li>Upload multiple files</li>\\n<li>Use a proxy</li>\\n<li>Retry on fail</li>\\n</ul>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Required</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>file</code></td>\\n<td><strong>\u2713</strong></td>\\n<td>File(s) to upload. Use <a href=\\"https://curl.se/docs/manpage.html#-T\\">curl syntax</a> for multiple (e.g. <code>{dogs.png,cats.jpg}</code>)</td>\\n</tr>\\n<tr>\\n<td><code>destination</code></td>\\n<td><strong>\u2713</strong></td>\\n<td>The WebDav <strong>folder</strong> url</td>\\n</tr>\\n<tr>\\n<td><code>username</code></td>\\n<td><strong>\u2713</strong></td>\\n<td>The WebDav-<strong>User</strong> to use</td>\\n</tr>\\n<tr>\\n<td><code>password</code></td>\\n<td></td>\\n<td>The <strong>Password</strong> for the WebDav-User</td>\\n</tr>\\n<tr>\\n<td><code>proxy_url</code></td>\\n<td></td>\\n<td>May be used to specify a proxy (e.g. <code>socks5://{ip_address}:{port}</code></td>\\n</tr>\\n<tr>\\n<td><code>timeout</code></td>\\n<td></td>\\n<td>Defines a timeout (in seconds) to stop the upload after a certain time</td>\\n</tr>\\n<tr>\\n<td><code>attempts</code></td>\\n<td></td>\\n<td>Defines how often a failed upload should be retried. Normally there is only one upload attempt</td>\\n</tr>\\n<tr>\\n<td><code>custom_arguments</code></td>\\n<td></td>\\n<td>Additional arguments to be passed to <a href=\\"https://curl.se/\\"><code>curl</code></a></td>\\n</tr>\\n</tbody></table>\\n<h2>Example</h2>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n  upload_debug:\\n    image: vividboarder/drone-webdav\\n    settings:\\n      file: com.vividboarder.otbeta/build/outputs/apk/com.vividboarder.otbeta-debug.apk\\n      destination: https://my.nextcloud.com/remote.php/dav/files/vividboarder/Android/Apks/\\n      username:\\n        from_secret: WEBDAV_USER\\n      password:\\n        from_secret: WEBDAV_PASSWORD\\n</code></pre>\\n","tags":["deploy","publish"],"containerImage":"vividboarder/drone-webdav","containerImageUrl":"https://hub.docker.com/r/vividboarder/drone-webdav","verified":false},{"name":"Aptly","url":"https://gitea.zionetrix.net/bn8/aptly-publish","icon":"https://www.aptly.info/img/logo.svg","description":"plugin to publish Debian package on a Aptly repository","docs":"<p>Woodpecker CI plugin to publish one (or more) Debian package on a Aptly repository using its API.</p>\\n<h2>Features</h2>\\n<p>This plugin will try to :</p>\\n<ul>\\n<li>List all changes files in the specified directory and filter on the specified source package name (if specified)</li>\\n<li>Iter on detected changes files and foreach of then:</li>\\n<li>the changes file is parsed to detect the source package name, the distribution and included files</li>\\n<li>the repository name is computed (if not specified). <strong>Format:</strong> <code>{prefix}_{distribution}_{component}</code>. <strong>Note:</strong> if the default prefix is specified (<code>.</code>), it will not be used to compute the repository name.</li>\\n<li>the current published distribution is retreived using APTLY Publish API to:<ul>\\n<li>check it was already manally published a first time</li>\\n<li>check it used a snapshot kind of sources</li>\\n<li>retreive other components source snapshot</li>\\n</ul>\\n</li>\\n<li>Upload the changes file and all its included files using APTLY File Upload API in a directory named as the source package</li>\\n<li>Include the changes file using APTLY Local Repos API</li>\\n<li>Compute a snapshot name for the repository based on the current date and the repository name. <strong>Format:</strong> <code>YYYYMMDD-HHMMSS_{repository name}</code></li>\\n<li>Create a snapshot of the repository using APTLY Local Repos API</li>\\n<li>Update the published distribution with this new snapshot as source of the specified component and keeping other components source snapshot.</li>\\n</ul>\\n<p>In case of error, it will exit with a detailed error message (within the limits of what is provided by the Aptly API).</p>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>api_url</code></td>\\n<td><em>none</em></td>\\n<td>Your Aptly API URL (required)</td>\\n</tr>\\n<tr>\\n<td><code>api_username</code></td>\\n<td><em>none</em></td>\\n<td>Username to authenticate on your Aptly API (required)</td>\\n</tr>\\n<tr>\\n<td><code>api_password</code></td>\\n<td><em>none</em></td>\\n<td>Password to authenticate on your Aptly API (required)</td>\\n</tr>\\n<tr>\\n<td><code>prefix</code></td>\\n<td><code>.</code></td>\\n<td>The publishing prefix</td>\\n</tr>\\n<tr>\\n<td><code>repo_component</code></td>\\n<td><code>main</code></td>\\n<td>The component name to publish on</td>\\n</tr>\\n<tr>\\n<td><code>repo_name</code></td>\\n<td><code>{prefix}_{distribution}_{component}</code></td>\\n<td>The repository name to publish on. If not specified, it will be computed using the specified prefix and component and the detected package distribution. See above for details.</td>\\n</tr>\\n<tr>\\n<td><code>path</code></td>\\n<td><code>dist</code></td>\\n<td>Path to the directory where files to publish are stored</td>\\n</tr>\\n<tr>\\n<td><code>source_name</code></td>\\n<td><em>none</em></td>\\n<td>Name of the source package to publish (optional, default: all <code>changes</code> files are will be publish)</td>\\n</tr>\\n<tr>\\n<td><code>max_retries</code></td>\\n<td><em>none</em></td>\\n<td>The number of retry in case of error calling the Aptly API (optional, default: no retry)</td>\\n</tr>\\n</tbody></table>\\n<h2>Example</h2>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n  publish:\\n    image: brenard/aptly-publish\\n    settings:\\n      api_url: https://your.aptly.tld/api\\n      api_username: myproject\\n      api_password:\\n        from_secret: aptly_api_password\\n      prefix: debian\\n      repo_component: main\\n      repo_name: debian_stable_main\\n      path: dist\\n      source_name: myproject\\n      max_retries: 2\\n</code></pre>\\n","tags":["APT","aptly","publish"],"containerImage":"brenard/aptly-publish","containerImageUrl":"https://hub.docker.com/r/brenard/aptly-publish","verified":false},{"name":"Trigger","url":"https://codeberg.org/woodpecker-plugins/trigger","icon":"https://woodpecker-ci.org/img/logo.svg","description":"plugin to trigger Woodpecker CI builds or deployments","docs":"<p>Woodpecker CI plugin to trigger repository builds or deployments. This plugin is a fork of <a href=\\"https://github.com/drone-plugins/drone-downstream/\\">drone-plugins/drone-downstream</a>.</p>\\n<h2>Features</h2>\\n<ul>\\n<li>Trigger one or multiple pipelines</li>\\n<li>Trigger deploy action</li>\\n<li>Pass variables to pipelines</li>\\n</ul>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>server</code></td>\\n<td>current server</td>\\n<td>sets Woodpecker CI server URL to call</td>\\n</tr>\\n<tr>\\n<td><code>token</code></td>\\n<td><em>none</em></td>\\n<td>sets Woocpecker CI API token for server</td>\\n</tr>\\n<tr>\\n<td><code>repositories</code></td>\\n<td><em>none</em></td>\\n<td>sets repositories name whose pipelines to trigger</td>\\n</tr>\\n<tr>\\n<td><code>deploy</code></td>\\n<td><em>none</em></td>\\n<td>sets the environment to deploy to</td>\\n</tr>\\n<tr>\\n<td><code>params</code></td>\\n<td><em>none</em></td>\\n<td>sets list of params (key=value or file paths of params) to pass to triggered builds</td>\\n</tr>\\n<tr>\\n<td><code>params-from-env</code></td>\\n<td><em>none</em></td>\\n<td>sets list of environment variables to pass to triggered builds</td>\\n</tr>\\n<tr>\\n<td><code>wait</code></td>\\n<td><code>false</code></td>\\n<td>sets to wait for any currently running builds to finish</td>\\n</tr>\\n<tr>\\n<td><code>timeout</code></td>\\n<td><code>60s</code></td>\\n<td>sets how long to wait on any currently running builds</td>\\n</tr>\\n<tr>\\n<td><code>last-successful</code></td>\\n<td><code>false</code></td>\\n<td>sets to trigger last successful build</td>\\n</tr>\\n</tbody></table>\\n<h3>repositories</h3>\\n<p>Multiple repositories whose pipelines need to be triggered can be provided.\\nAlso it\'s possible to provide specific branch to trigger can be specified with <code>@</code> separator, ex. <code>owner/repo@branch</code>.</p>\\n<h2>Examples</h2>\\n<pre><code class=\\"language-yaml\\">  trigger-downstream:\\n    image: woodpeckerci/plugin-trigger\\n    settings:\\n      repositories:\\n        - octocat/hello-world@master\\n        - octocat/sample\\n      token:\\n        from_secret: woodpecker_token\\n</code></pre>\\n<pre><code class=\\"language-yaml\\">  publish:\\n    image: woodpeckerci/plugin-trigger\\n    settings:\\n      repositories:\\n        - octocat/hello-world\\n      deploy: production\\n      params:\\n        - DATABASE=prod\\n      wait: true\\n      token:\\n        from_secret: woodpecker_token\\n    when:\\n      branch: ${CI_REPO_DEFAULT_BRANCH}\\n      event: push\\n</code></pre>\\n","tags":["woodpecker","trigger","pipeline"],"containerImage":"woodpeckerci/plugin-trigger","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-trigger","verified":true},{"name":"Gitea Release","url":"https://codeberg.org/woodpecker-plugins/gitea-release","icon":"https://raw.githubusercontent.com/go-gitea/gitea/main/assets/logo.svg","description":"Plugin to create a Gitea release","docs":"<p>Woodpecker CI plugin to create a Gitea release. This plugin is a fork of <a href=\\"https://github.com/drone-plugins/drone-gitea-release\\">drone-gitea-release</a>.</p>\\n<p>If the release already exists matching the tag, it will be used without overwriting. Files will still be uploaded based on the <code>file-exists</code> setting.</p>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>api-key</code></td>\\n<td><em>none</em></td>\\n<td>Access Token for Gitea; required scope: <code>repo</code> (&lt;=1.19) or <code>write:repository</code> and <code>read:misc</code> (&gt;=1.20)</td>\\n</tr>\\n<tr>\\n<td><code>files</code></td>\\n<td><em>none</em></td>\\n<td>List of files to upload (accepts <a href=\\"https://pkg.go.dev/path/filepath#Match\\">globs</a>)</td>\\n</tr>\\n<tr>\\n<td><code>file-exists</code></td>\\n<td><code>overwrite</code></td>\\n<td>What to do if files already exist; one of <code>overwrite</code>, <code>fail</code>, or <code>skip</code></td>\\n</tr>\\n<tr>\\n<td><code>checksum</code></td>\\n<td><em>none</em></td>\\n<td>Generate checksums for specific files</td>\\n</tr>\\n<tr>\\n<td><code>target</code></td>\\n<td><em>none</em></td>\\n<td>Branch where further development happens (usually <code>main</code>)</td>\\n</tr>\\n<tr>\\n<td><code>draft</code></td>\\n<td><code>false</code></td>\\n<td>Create a draft release</td>\\n</tr>\\n<tr>\\n<td><code>skip-verify</code></td>\\n<td><code>false</code></td>\\n<td>Visit <code>base-url</code> and skip verifying certificate</td>\\n</tr>\\n<tr>\\n<td><code>prerelease</code></td>\\n<td><code>false</code></td>\\n<td>Create a pre-release</td>\\n</tr>\\n<tr>\\n<td><code>base-url</code></td>\\n<td><em>none</em></td>\\n<td>Base URL of Gitea instance</td>\\n</tr>\\n<tr>\\n<td><code>note</code></td>\\n<td><em>none</em></td>\\n<td>File or string with notes for the release (ex: changelog)</td>\\n</tr>\\n<tr>\\n<td><code>title</code></td>\\n<td><em>none</em></td>\\n<td>File or string with the title for the release</td>\\n</tr>\\n<tr>\\n<td><code>env-file</code></td>\\n<td><em>none</em></td>\\n<td>Path to a <code>.env</code> file to load</td>\\n</tr>\\n</tbody></table>\\n<h2>Example</h2>\\n<pre><code class=\\"language-yaml\\">  publish:\\n    image: woodpeckerci/plugin-gitea-release\\n    settings:\\n        base_url: https://codeberg.org\\n        files:\\n          # Could also be \\"hello-world*\\" to match both\\n          - \\"hello-world\\"\\n          - \\"hello-world.exe\\"\\n        api_key:\\n          from_secret: GITEA_ACCESS_TOKEN\\n        target: main\\n</code></pre>\\n","tags":["Gitea","publish"],"containerImage":"woodpeckerci/plugin-gitea-release","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-gitea-release","verified":true},{"name":"Woodpecker Email","url":"https://gitnet.fr/deblan/woodpecker-email","icon":"https://gitnet.fr/deblan/woodpecker-email/raw/branch/develop/logo.svg","description":"plugin to send build status notifications via Email.","docs":"<p>Use the Email plugin for sending build status notifications via email.</p>\\n<h2>Config</h2>\\n<p>You can configure the plugin using the following parameters:</p>\\n<ul>\\n<li><strong>from.address</strong> - Send notifications from this address</li>\\n<li><strong>from.name</strong> - Notifications sender name</li>\\n<li><strong>host</strong> - SMTP server host</li>\\n<li><strong>port</strong> - SMTP server port, defaults to <code>587</code></li>\\n<li><strong>username</strong> - SMTP username</li>\\n<li><strong>password</strong> - SMTP password</li>\\n<li><strong>skip_verify</strong> - Skip verification of SSL certificates, defaults to <code>false</code></li>\\n<li><strong>no_starttls</strong> - Enable/Disable STARTTLS</li>\\n<li><strong>recipients</strong> - List of recipients to send this mail to (besides the commit author)</li>\\n<li><strong>recipients_file</strong> - Filename to load additional recipients from (textfile with one email per line) (besides the commit author)</li>\\n<li><strong>recipients_only</strong> - Do not send mails to the commit author, but only to <strong>recipients</strong>, defaults to <code>false</code></li>\\n<li><strong>subject</strong> - The subject line template</li>\\n<li><strong>body</strong> - The email body template</li>\\n<li><strong>attachment</strong> - An optional file to attach to the sent mail(s), can be an absolute path or relative to the working directory.</li>\\n<li><strong>evaluate</strong> - An optional expression to evaluate (on the fly) whether the mail should be sent or not (<a href=\\"https://woodpecker-ci.org/docs/next/usage/pipeline-syntax#evaluate\\">https://woodpecker-ci.org/docs/next/usage/pipeline-syntax#evaluate</a>).</li>\\n</ul>\\n<h2>Example</h2>\\n<p>The following is a sample configuration in your .woodpecker.yml file:</p>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n  mail:\\n    image: deblan/woodpecker-email\\n    settings:\\n      from.address: noreply@github.com\\n      from.name: John Smith\\n      host: smtp.mailgun.org\\n      username: octocat\\n      password: 12345\\n      recipients:\\n        - octocat@github.com\\n</code></pre>\\n<h3>Secrets</h3>\\n<p>The Email plugin supports reading credentials and other parameters from the Drone secret store. This is strongly recommended instead of storing credentials in the pipeline configuration in plain text.</p>\\n<pre><code class=\\"language-diff\\">pipeline:\\n  mail:\\n    image: deblan/woodpecker-email\\n    settings:\\n      from.address: noreply@github.com\\n      host: smtp.mailgun.org\\n+     username:\\n+       from_secret: email_username\\n+     password: 12345\\n+       from_secret: email_password\\n      recipients:\\n        - octocat@github.com\\n</code></pre>\\n<h3>Evaluation</h3>\\n<p>This plugin introduces an optional expression to evaluate (on the fly) whether the mail should be sent or not.</p>\\n<pre><code class=\\"language-diff\\">pipeline:\\n  mail:\\n    image: deblan/woodpecker-email\\n    settings:\\n      ...\\n    when:\\n      - evaluate: \'CI_STEP_STATUS == \\"failure\\" || CI_PREV_PIPELINE_STATUS == \\"failure\\"\'\\n</code></pre>\\n<p>The problem is that the expression is evaluated before the pipeline is generated. In this case, <code>CI_STEP_STATUS</code> does not exist yet and the mail step is ignored unless the previous pipeline failed.</p>\\n<pre><code class=\\"language-diff\\">pipeline:\\n  mail:\\n    image: deblan/woodpecker-email\\n    settings:\\n      ...\\n+     evaluate: \'CI_STEP_STATUS == \\"failure\\" || CI_PREV_PIPELINE_STATUS == \\"failure\\"\'\\n    when:\\n-     - evaluate: \'CI_STEP_STATUS == \\"failure\\" || CI_PREV_PIPELINE_STATUS == \\"failure\\"\'\\n</code></pre>\\n<p>More information about the syntaxe on (<a href=\\"https://woodpecker-ci.org/docs/next/usage/pipeline-syntax#evaluate\\">https://woodpecker-ci.org/docs/next/usage/pipeline-syntax#evaluate</a>).</p>\\n<h3>Custom Templates</h3>\\n<p>In some cases you may want to customize the look and feel of the email message\\nso you can use custom templates. For the use case we expose the following\\nadditional parameters, all of the accept a custom handlebars template, directly\\nprovided as a string or as a remote URL which gets fetched and parsed:</p>\\n<ul>\\n<li><strong>subject</strong> - A handlebars template to create a custom subject. For more\\ndetails take a look at the <a href=\\"http://handlebarsjs.com/\\">docs</a>. You can see the\\ndefault template <a href=\\"https://github.com/Drillster/drone-email/blob/master/defaults.go#L14\\">here</a></li>\\n<li><strong>body</strong> - A handlebars template to create a custom template. For more\\ndetails take a look at the <a href=\\"http://handlebarsjs.com/\\">docs</a>. You can see the\\ndefault template <a href=\\"https://github.com/Drillster/drone-email/blob/master/defaults.go#L19-L267\\">here</a></li>\\n</ul>\\n<p>Example configuration that generate a custom email:</p>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n  mail:\\n    image: deblan/woodpecker-email\\n    settings:\\n      from.address: noreply@github.com\\n      host: smtp.mailgun.org\\n      username: octocat\\n      password: 12345\\n      subject: &gt;\\n        [{{ build.status }}]\\n        {{ repo.owner }}/{{ repo.name }}\\n        ({{ build.branch }} - {{ truncate build.commit 8 }})\\n      body:\\n        https://git.io/vgvPz\\n</code></pre>\\n<h3>Skip SSL verify</h3>\\n<p>In some cases you may want to skip SSL verification, even if we discourage that\\nas it leads to an unsecure environment. Please use this option only within your\\nintranet and/or with truested resources. For this use case we expose the\\nfollowing additional parameter:</p>\\n<ul>\\n<li><strong>skip_verify</strong> - Skip verification of SSL certificates</li>\\n</ul>\\n<p>Example configuration that skips SSL verification:</p>\\n<pre><code class=\\"language-diff\\">pipeline:\\n  mail:\\n    image: deblan/woodpecker-email\\n    settings:\\n      from: noreply@github.com\\n      host: smtp.mailgun.org\\n      username: octocat\\n      password: 12345\\n+     skip_verify: true\\n</code></pre>\\n<h3>STARTTLS</h3>\\n<p>By default, STARTTLS is being used opportunistically meaning, if advertised\\nby the server, traffic is going to be encrypted.</p>\\n<p>You may want to disable STARTTLS, e.g., with faulty and/or internal servers:</p>\\n<pre><code class=\\"language-diff\\">pipeline:\\n  mail:\\n    image: deblan/woodpecker-email\\n    settings:\\n      from: noreply@github.com\\n      host: smtp.mailgun.org\\n      username: octocat\\n      password: 12345\\n+     no_starttls: true\\n</code></pre>\\n","tags":["notifications","email"],"containerImage":"deblan/woodpecker-email","containerImageUrl":"https://hub.docker.com/r/deblan/woodpecker-email","verified":false},{"name":"Woodpecker Feishu Bot","url":"https://github.com/wenerme/wode/tree/main/apps/woodpecker-feishu-bot","description":"Send notify to feishu/\u98de\u4e66 in text or markdown format","docs":"<h2>Example</h2>\\n<pre><code class=\\"language-yaml\\">variables:\\n  - &amp;notify_image \'wener/woodpecker-feishu-bot\'\\n\\npipeline:\\n  Notify Start:\\n    image: *notify_image\\n    settings:\\n      feishu_bot_url:\\n        from_secret: feishu_bot_url\\n      feishu_bot_secret:\\n        from_secret: feishu_bot_secret\\n      markdown: |\\n        \ud83c\udfd7\ufe0f Start building &lt;%= env.CI_REPO_NAME %&gt; #&lt;%= env.CI_BUILD_NUMBER %&gt;\\n\\n        - &lt;%= $.link(env.CI_COMMIT,env.CI_COMMIT_LINK) %&gt; &lt;%=env.CI_COMMIT_MESSAGE.replaceAll(/\\\\n/g,\';\')%&gt;\\n\\n        \ud83d\udce6\ufe0f &lt;%=$.link(env.CI_REPO_NAME,env.CI_BUILD_LINK)%&gt;\\n\\n  # Do the real work\\n\\n  Notify Done:\\n    image: *notify_image\\n    settings:\\n      feishu_bot_url:\\n        from_secret: feishu_bot_url\\n      feishu_bot_secret:\\n        from_secret: feishu_bot_secret\\n      markdown: |\\n        &lt;%= env.CI_PIPELINE_STATUS === \'success\' ? \'\u2705\' : \'\u274c\' %&gt; Building complete &lt;%= env.CI_REPO_NAME %&gt; #&lt;%= env.CI_BUILD_NUMBER %&gt;\\n\\n        - &lt;%= env.CI_COMMIT_MESSAGE %&gt;\\n\\n        \ud83d\udce6\ufe0f &lt;%= $.link(env.CI_REPO_NAME, env.CI_BUILD_LINK) %&gt; \xb7 \u23f3&lt;%= env.CI_PIPELINE_FINISHED - env.CI_PIPELINE_STARTED %&gt;\\n    when:\\n      status: [ success, failure ]\\n</code></pre>\\n<h2>settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>setting</th>\\n<th>for</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>feisbu_bot_url</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>feisbu_bot_secret</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>content</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>format</td>\\n<td>format of content, default to markdown</td>\\n</tr>\\n<tr>\\n<td>markdown</td>\\n<td>=content+format=markdown</td>\\n</tr>\\n<tr>\\n<td>text</td>\\n<td>=content+format=text</td>\\n</tr>\\n<tr>\\n<td>dry_run</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>debug</td>\\n<td>print env</td>\\n</tr>\\n<tr>\\n<td>template</td>\\n<td>render as eta template, default to true</td>\\n</tr>\\n<tr>\\n<td>failsafe</td>\\n<td>if true, ignore error</td>\\n</tr>\\n</tbody></table>\\n<ul>\\n<li>eta template context<ul>\\n<li>env -&gt; process.env</li>\\n<li>fs -&gt; fs-extra</li>\\n</ul>\\n</li>\\n</ul>\\n","tags":["notify"],"containerImage":"wener/woodpecker-feishu-bot","containerImageUrl":"https://hub.docker.com/r/wener/woodpecker-feishu-bot","verified":false},{"name":"ntfy","url":"https://codeberg.org/l-x/woodpecker-ntfy","description":"plugin to send notifications to a ntfy.sh instance","docs":"<h1>woodpecker-ntfy</h1>\\n<p>A <a href=\\"https://woodpecker-ci.org/\\">Woodpecker</a> plugin to send notifications to a <a href=\\"http://ntfy.sh/\\">ntfy.sh</a> instance.</p>\\n<h2>Configuration</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Name</th>\\n<th>Description</th>\\n<th>Default</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>message</code></td>\\n<td>Notification Body</td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>title</code></td>\\n<td>Notification Title <a href=\\"https://docs.ntfy.sh/publish/#message-title\\">^message-title</a></td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>priority</code></td>\\n<td>Notification Priority <a href=\\"https://docs.ntfy.sh/publish/#message-priority\\">^message-priority</a></td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>url</code></td>\\n<td>Url (including the topic) to send the notification to</td>\\n<td><code>https://ntfy.sh/woodpecker-ntfy</code></td>\\n</tr>\\n<tr>\\n<td><code>token</code></td>\\n<td>Authentication token for write-protected topics <a href=\\"https://docs.ntfy.sh/publish/#bearer-auth\\">^bearer-auth</a></td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>actions</code></td>\\n<td>Action Buttons <a href=\\"https://docs.ntfy.sh/publish/#defining-actions\\">^defining-actions</a></td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>attach</code></td>\\n<td>Url for file to be attached <a href=\\"https://docs.ntfy.sh/publish/#attach-file-from-a-url\\">^attach-file-from-a-url</a></td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>call</code></td>\\n<td>Phone number to send voice message to <a href=\\"https://docs.ntfy.sh/publish/#phone-calls\\">^phone-calls</a> (ntfy &gt;= 2.5.0)</td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>click</code></td>\\n<td>Click Action <a href=\\"https://docs.ntfy.sh/publish/#click-action\\">^click-action</a></td>\\n<td><code>CI_BUILD_LINK</code></td>\\n</tr>\\n<tr>\\n<td><code>email</code></td>\\n<td>E-mail to which the message is to be forwarded <a href=\\"https://docs.ntfy.sh/publish/#e-mail-notifications\\">^e-mail-notifications</a></td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>icon</code></td>\\n<td>Message Icon <a href=\\"https://docs.ntfy.sh/publish/#icons\\">^icons</a></td>\\n<td><code>CI_COMMIT_AUTHOR_AVATAR</code></td>\\n</tr>\\n<tr>\\n<td><code>tags</code></td>\\n<td>Tags and Emojis <a href=\\"https://docs.ntfy.sh/publish/#tags-emojis\\">^tags-emojis</a></td>\\n<td>none</td>\\n</tr>\\n</tbody></table>\\n<h2>Example</h2>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n    ntfy:\\n        image: codeberg.org/l-x/woodpecker-ntfy\\n        settings:\\n            url: https://custom.ntfy.instance/topic-to-notify\\n            token:\\n                from_secret: your-super-secret-ntfy-access-token\\n            title: notification title\\n            priority: urgent\\n            actions: \\"view, Open portal, https://home.nest.com/, clear=true; http, Turn down, https://api.nest.com/, body=\'{\\\\\\"temperature\\\\\\": 65}\'\\"\\n            click: https://where.to.go\\n            icon: https://woodpecker-ci.org/img/logo.svg\\n            tags: robot,${CI_BUILD_EVENT},${CI_REPO_NAME}\\n            message: &gt;\\n                \ud83d\udcdd Commit by ${CI_COMMIT_AUTHOR} on ${CI_COMMIT_BRANCH}:\\n\\n                ${CI_COMMIT_MESSAGE}\\n</code></pre>\\n","tags":["trigger","notify"],"containerImage":"codeberg.org/l-x/woodpecker-ntfy","containerImageUrl":"https://codeberg.org/l-x/-/packages/container/woodpecker-ntfy/latest","verified":false},{"name":"Trivy","url":"https://codeberg.org/woodpecker-plugins/trivy","icon":"https://aquasecurity.github.io/trivy/v0.41/imgs/logo.png","description":"Plugin to find vulnerabilities, misconfigurations, secrets, SBOM and more.","docs":"<p>A plugin to find vulnerabilities, misconfigurations, secrets, SBOM and more.</p>\\n<p>The below pipeline configuration demonstrates simple usage:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  scan_vuln:\\n    image: woodpeckerci/plugin-trivy\\n</code></pre>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>exit-code</code></td>\\n<td><code>1</code></td>\\n<td>if an issue is detected let the step fail</td>\\n</tr>\\n<tr>\\n<td><code>skip-dirs</code></td>\\n<td><code>vendor,node_modules</code></td>\\n<td>folders excluded from scan</td>\\n</tr>\\n<tr>\\n<td><code>dir</code></td>\\n<td><code>.</code></td>\\n<td>root folder to scan from</td>\\n</tr>\\n<tr>\\n<td><code>server</code></td>\\n<td><em>none</em></td>\\n<td>use a trivy server, can be a service step or extern</td>\\n</tr>\\n<tr>\\n<td><code>severity</code></td>\\n<td><em>none</em></td>\\n<td>severities of security issues to be displayed (comma separated) (default \\"UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL\\")</td>\\n</tr>\\n</tbody></table>\\n","tags":["check","security","trivy","vulnerabilities","misconfigurations","secrets"],"containerImage":"woodpeckerci/plugin-trivy","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-trivy","verified":true},{"name":"MkDocs","url":"https://codeberg.org/woodpecker-plugins/mkdocs","icon":"https://codeberg.org/woodpecker-plugins/mkdocs/raw/branch/main/mkdocs-icon.png","description":"Plugin to build mkdocs sites","docs":"<h2>Setup</h2>\\n<p>Add the following to your woodpecker file\'s <code>steps</code> section to build docs using the default installation (See <code>Bundled libraries</code> below) and settings of this plugin.<br>Make sure to replace <code>{version}</code> with the latest release available or with <code>latest</code> for the latest commit made.</p>\\n<pre><code class=\\"language-yaml\\">buildDocs:\\n  image: woodpeckerci/plugin-mkdocs:{version}\\n</code></pre>\\n<p>A minimal version without any bundled libraries is offered too. Use the following to use the minimal version:</p>\\n<pre><code class=\\"language-yaml\\">buildDocs:\\n  image: woodpeckerci/plugin-mkdocs:minimal\\n</code></pre>\\n<p>Settings can be defined using the <code>settings</code> option for woodpecker plugins. All available settings and their defaults are listed below.</p>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>clean</code></td>\\n<td><code>true</code></td>\\n<td>remove old files from the <code>site_dir</code> before building</td>\\n</tr>\\n<tr>\\n<td><code>site_dir</code></td>\\n<td><code>site_dir</code> config option or <code>site</code></td>\\n<td>directory to output the result of the documentation build, if also not set in config <code>site</code> is used</td>\\n</tr>\\n<tr>\\n<td><code>directory_urls</code></td>\\n<td><code>true</code></td>\\n<td>use directory URLs when building pages</td>\\n</tr>\\n<tr>\\n<td><code>config</code></td>\\n<td><code>mkdocs.yml</code></td>\\n<td>provide a specific MkDocs config</td>\\n</tr>\\n<tr>\\n<td><code>strict</code></td>\\n<td><code>false</code></td>\\n<td>will cause MkDocs to abort the build on any warnings</td>\\n</tr>\\n<tr>\\n<td><code>theme</code></td>\\n<td><code>mkdocs</code></td>\\n<td>theme to use when building your documentation (<code>mkdocs</code> or <code>readthedocs</code>). Other themes need to be installed manually using <code>pip_install</code></td>\\n</tr>\\n<tr>\\n<td><code>verbose</code></td>\\n<td><code>false</code></td>\\n<td>enable verbose mode</td>\\n</tr>\\n<tr>\\n<td><code>pip_install_file</code></td>\\n<td><em>none</em></td>\\n<td>Add a file to install dependencies from using <code>pip install -r &lt;file&gt;</code> before mkdocs is exec</td>\\n</tr>\\n<tr>\\n<td><code>pip_install</code></td>\\n<td><em>none</em></td>\\n<td>Add comma separated packages to be installed by pip before mkdocs is exec</td>\\n</tr>\\n</tbody></table>\\n<h2>Bundled libraries</h2>\\n<p>The plugin base is <a href=\\"https://hub.docker.com/r/squidfunk/mkdocs-material\\"><code>squidfunk/mkdocs-material</code></a>. For all the non-minimal images, the following additional dependencies are bundled:</p>\\n<ul>\\n<li><code>mkdocs-enumerate-headings-plugin</code></li>\\n<li><code>mkdocs-git-authors-plugin</code></li>\\n<li><code>mkdocs-git-revision-date-localized</code></li>\\n<li><code>mkdocs-glightbox</code></li>\\n<li><code>mkdocs-print-site-plugin</code></li>\\n</ul>\\n","tags":["mkdocs","docs"],"containerImage":"woodpeckerci/plugin-mkdocs","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-mkdocs","verified":true},{"name":"TODO-Checker","url":"https://codeberg.org/Epsilon_02/todo-checker","description":"Plugin to check if TODOs has an open issue number to the project repository (currently only gitea/forgejo supported)","docs":"<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>prefix_regex</code></td>\\n<td><code>(TODO|FIXME)</code></td>\\n<td>prefix which should a comment start to check if there should exist a issue number</td>\\n</tr>\\n<tr>\\n<td><code>main_regex</code></td>\\n<td><code>( |)(\\\\(|\\\\(#)(?P&lt;ISSUE_NUMBER&gt;\\\\d+)(\\\\))</code></td>\\n<td>main regex to check how the issue number should be defined. IMPORTANT: if you want to build a custom regex, the name of the capturing group \\"ISSUE_NUMBER\\" have to be defined which only returns the issue-number!</td>\\n</tr>\\n<tr>\\n<td><code>repository_token</code></td>\\n<td>``</td>\\n<td>token if the repository to be checked is private</td>\\n</tr>\\n<tr>\\n<td><code>debug</code></td>\\n<td><code>false</code></td>\\n<td>enable debug output</td>\\n</tr>\\n</tbody></table>\\n<h3>Building custom regex</h3>\\n<p>This plugin uses <a href=\\"https://github.com/BurntSushi/ripgrep\\">ripgrep</a> to search through project files which uses the <a href=\\"https://docs.rs/regex/1.8.3/regex/#syntax\\">rust regex syntax</a>.</p>\\n<h3>Ignore files</h3>\\n<p>Ripgrep pays attention to the following files: <code>.rgignore</code>, <code>.ignore</code> and <code>.gitignore</code>.\\nIt treats <code>.rgignore</code>-files with higher precedence than <code>.ignore</code>-files and <code>.ignore</code>-files with a higher precedence than `.gitignore.\\nCheck also the <a href=\\"https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md#automatic-filtering\\">ripgrep manual</a> out for further reading.</p>\\n","tags":["todo","testing"],"containerImage":"codeberg.org/epsilon_02/todo-checker","verified":false},{"name":"Nextcloud Upload","url":"https://github.com/Ellpeck/WoodpeckerPlugins/tree/main/nextcloud-upload","description":"Upload files to Nextcloud using chunking and optionally add tags to files","docs":"<h1>Nextcloud Upload</h1>\\n<p>Simple plugin to upload files to Nextcloud using chunking, based on a glob pattern and a destination location. Note that, since this uses Nextcloud\'s built-in chunking system, it likely doesn\'t work for other WebDAV applications.</p>\\n<p>Here\'s an example of how to use it:</p>\\n<pre><code class=\\"language-yml\\">steps:\\n  upload:\\n    image: ellpeck/woodpecker-nextcloud-upload\\n    settings:\\n      # required settings\\n      server: https://cloud.ellpeck.de # the server to use\\n      user: EllBot # the user\\n      token: access-token # the access token, or password if 2FA is disabled\\n      files: # the file(s), uses glob patterns\\n        - \\"**/*.md\\"\\n      dest: Uploads/CoolMarkdownFiles # the destination directory\\n\\n      # optional retention settings, useful if old builds should be deleted automatically\\n      retentionamount: 7 # amount of children that retentionbase is allowed to have before oldest ones are deleted on upload\\n      retentionbase: Uploads # directory that the retentionamount applies to\\n      retentionskiptrash: false # whether retention-based deletion should skip the Nextcloud trash, defaults to false\\n\\n      # misc optional settings\\n      basedir: \\".\\" # local base directory for files, defaults to .\\n      chunksize: # chunk size in bytes, defaults to 10485760, or 10 MiB\\n      quiet: false # whether to reduce output, defaults to false\\n      tags: # a set of tags to apply to uploaded files, tag is expected to already exist\\n        - mytag\\n      flatten: false # whether to flatten directories, causing all files to be placed directly in dest, defaults to false\\n</code></pre>\\n","tags":["deploy","publish"],"containerImage":"ellpeck/woodpecker-nextcloud-upload","containerImageUrl":"https://hub.docker.com/r/ellpeck/woodpecker-nextcloud-upload","verified":false},{"name":"Kubernetes Deployment or StatefulSet Update","url":"https://github.com/euryecetelecom/woodpeckerci-kubernetes","description":"Update a Kubernetes deployment or statefulset","docs":"<h1>Kubernetes plugin for Woodpecker-CI</h1>\\n<p>This plugin allows to update a Kubernetes deployment or statefulset.</p>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Setting Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>kubernetes_server</code></td>\\n<td><em>none</em></td>\\n<td>Kubernetes server to target (ex: <a href=\\"https://mykubernetes.example.com\\">https://mykubernetes.example.com</a>) - mandatory</td>\\n</tr>\\n<tr>\\n<td><code>kubernetes_token</code></td>\\n<td><em>none</em></td>\\n<td>Kubernetes token to use (cf Generating secrets) - mandatory / B64 encoded</td>\\n</tr>\\n<tr>\\n<td><code>kubernetes_cert</code></td>\\n<td><em>none</em></td>\\n<td>Kubernetes certificate to use (cf Generating secrets) / B64 encoded</td>\\n</tr>\\n<tr>\\n<td><code>kubernetes_user</code></td>\\n<td><code>default</code></td>\\n<td>Kubernetes user to use</td>\\n</tr>\\n<tr>\\n<td><code>deployment</code></td>\\n<td><em>none</em></td>\\n<td>Deployment(s) to update - at least 1 deployment or statefulset are mandatory</td>\\n</tr>\\n<tr>\\n<td><code>statefulset</code></td>\\n<td><em>none</em></td>\\n<td>StatefulSet(s) to update - at least 1 deployment or statefulset are mandatory</td>\\n</tr>\\n<tr>\\n<td><code>namespace</code></td>\\n<td><code>default</code></td>\\n<td>Deployment or StatefulSet namespace</td>\\n</tr>\\n<tr>\\n<td><code>repo</code></td>\\n<td><em>none</em></td>\\n<td>Repository containing the image to pull from (ex: myrepo.example.com/project/image) - mandatory</td>\\n</tr>\\n<tr>\\n<td><code>container</code></td>\\n<td><em>none</em></td>\\n<td>Container(s) to update with the image - mandatory</td>\\n</tr>\\n<tr>\\n<td><code>tag</code></td>\\n<td><em>none</em></td>\\n<td>Image tag to pull from - mandatory</td>\\n</tr>\\n<tr>\\n<td><code>wait</code></td>\\n<td><em>none</em></td>\\n<td>Wait for update to be applied (ex: true)</td>\\n</tr>\\n<tr>\\n<td><code>wait_timeout</code></td>\\n<td><code>30s</code></td>\\n<td>Wait timeout</td>\\n</tr>\\n<tr>\\n<td><code>force</code></td>\\n<td><em>none</em></td>\\n<td>Force pull the new image, to ensure an image with the same tag is updated (ex: true)</td>\\n</tr>\\n</tbody></table>\\n<h2>Usage</h2>\\n<h3>Update a container from one Deployment</h3>\\n<p>This pipeline will update the <code>my-deployment</code> deployment with the image tagged <code>CI_COMMIT_SHA</code></p>\\n<pre><code class=\\"language-yaml\\">    deploy:\\n        image: euryecetelecom/woodpeckerci-kubernetes\\n        settings:\\n            kubernetes_server:\\n                from_secret: kubernetes_server\\n            kubernetes_token:\\n                from_secret: kubernetes_token\\n            kubernetes_cert:\\n                from_secret: kubernetes_cert\\n            namespace: default\\n            deployment: my-deployment\\n            repo: myorg/myrepo\\n            container: my-container\\n            tag: ${CI_COMMIT_BRANCH}\\n        secrets:\\n            - kubernetes_cert\\n            - kubernetes_server\\n            - kubernetes_token\\n</code></pre>\\n<h3>Update a container from one StatefulSet</h3>\\n<p>This pipeline will update the <code>my-statefulset</code> statefulset with the image tagged <code>CI_COMMIT_SHA</code></p>\\n<pre><code class=\\"language-yaml\\">    deploy:\\n        image: euryecetelecom/woodpeckerci-kubernetes\\n        settings:\\n            kubernetes_server:\\n                from_secret: kubernetes_server\\n            kubernetes_token:\\n                from_secret: kubernetes_token\\n            kubernetes_cert:\\n                from_secret: kubernetes_cert\\n            namespace: default\\n            statefulset: my-statefulset\\n            repo: myorg/myrepo\\n            container: my-container\\n            tag: ${CI_COMMIT_BRANCH}\\n        secrets:\\n            - kubernetes_cert\\n            - kubernetes_server\\n            - kubernetes_token\\n</code></pre>\\n<h3>Update a container from one Deployment, force rollout and wait for it</h3>\\n<p>This pipeline will update the <code>my-deployment</code> deployment with the image tagged <code>CI_COMMIT_SHA</code>, force rollout and wait 300s (default is 30s) for it to be ready. This helps to ensure the next pipeline step is based on the deployed container - for automatic testing purposes for example.</p>\\n<pre><code class=\\"language-yaml\\">    deploy:\\n        image: euryecetelecom/woodpeckerci-kubernetes\\n        settings:\\n            kubernetes_server:\\n                from_secret: kubernetes_server\\n            kubernetes_token:\\n                from_secret: kubernetes_token\\n            kubernetes_cert:\\n                from_secret: kubernetes_cert\\n            namespace: default\\n            wait: true\\n            wait_timeout: 60s\\n            force: true\\n            deployment: my-deployment\\n            repo: myorg/myrepo\\n            container: my-container\\n            tag: ${CI_COMMIT_BRANCH}\\n        secrets:\\n            - kubernetes_cert\\n            - kubernetes_server\\n            - kubernetes_token\\n</code></pre>\\n<h3>Update a container from several Deployments</h3>\\n<p>Deploying containers across several deployments, eg in a scheduler-worker setup. Make sure your container <code>name</code> in your manifest is the same for each pod.</p>\\n<pre><code class=\\"language-yaml\\">    deploy:\\n        image: euryecetelecom/woodpeckerci-kubernetes\\n        settings:\\n            kubernetes_server:\\n                from_secret: kubernetes_server\\n            kubernetes_token:\\n                from_secret: kubernetes_token\\n            kubernetes_cert:\\n                from_secret: kubernetes_cert\\n            namespace: default\\n            deployment: [server-deploy, worker-deploy]\\n            repo: myorg/myrepo\\n            container: my-container\\n            tag: ${CI_COMMIT_BRANCH}\\n        secrets:\\n            - kubernetes_cert\\n            - kubernetes_server\\n            - kubernetes_token\\n</code></pre>\\n<h3>Update multiple container from a Deployment</h3>\\n<p>Deploying multiple containers within the same deployment.</p>\\n<pre><code class=\\"language-yaml\\">    deploy:\\n        image: euryecetelecom/woodpeckerci-kubernetes\\n        settings:\\n            kubernetes_server:\\n                from_secret: kubernetes_server\\n            kubernetes_token:\\n                from_secret: kubernetes_token\\n            kubernetes_cert:\\n                from_secret: kubernetes_cert\\n            namespace: default\\n            deployment: my-deployment\\n            repo: myorg/myrepo\\n            container: [container1, container2]\\n            tag: ${CI_COMMIT_BRANCH}\\n        secrets:\\n            - kubernetes_cert\\n            - kubernetes_server\\n            - kubernetes_token\\n</code></pre>\\n<h3>TODO: To be tested - multiple containers from multiple deployments</h3>\\n<h2>Required secrets</h2>\\n<pre><code class=\\"language-bash\\">    woodpecker-cli secret add --image=infras/woodpeckerci-kubernetes \\\\\\n        your-org/your-repo KUBERNETES_SERVER https://mykubernetesapiserver\\n\\n    woodpecker-cli secret add --image=infras/woodpeckerci-kubernetes \\\\\\n        your-org/your-repo KUBERNETES_CERT &lt;base64 encoded CA.crt&gt;\\n\\n    woodpecker-cli secret add --image=infras/woodpeckerci-kubernetes \\\\\\n        your-org/your-repo KUBERNETES_TOKEN eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJrdWJ...\\n</code></pre>\\n<p>When using TLS Verification, ensure Server Certificate used by kubernetes API server \\nis signed for SERVER url ( could be a reason for failures if using aliases of kubernetes cluster )</p>\\n<h2>Generating secrets - RBAC</h2>\\n<p>When using a version of kubernetes with RBAC (role-based access control)\\nenabled, you will not be able to use the default service account, since it does\\nnot have access to update deployments.  Instead, you will need to create a\\ncustom service account with the appropriate permissions (<code>Role</code> and <code>RoleBinding</code>, or <code>ClusterRole</code> and <code>ClusterRoleBinding</code> if you need access across namespaces using the same service account).</p>\\n<p>As an example (for the <code>default</code> namespace):</p>\\n<pre><code class=\\"language-yaml\\">apiVersion: v1\\nkind: ServiceAccount\\nmetadata:\\n  name: cicd-deploy\\n  namespace: default\\nautomountServiceAccountToken: true\\n\\n---\\n\\napiVersion: rbac.authorization.k8s.io/v1\\nkind: Role\\nmetadata:\\n  name: cicd-deploy\\n  namespace: default\\nrules:\\n  - apiGroups: [\\"apps\\"]\\n    resources: [\\"deployments\\"]\\n    verbs: [\\"get\\",\\"list\\",\\"patch\\",\\"update\\", \\"watch\\"]\\n\\n---\\n\\napiVersion: rbac.authorization.k8s.io/v1\\nkind: RoleBinding\\nmetadata:\\n  name: cicd-deploy\\n  namespace: default\\nsubjects:\\n  - kind: ServiceAccount\\n    name: cicd-deploy\\n    namespace: default\\nroleRef:\\n  kind: Role\\n  name: cicd-deploy\\n  apiGroup: rbac.authorization.k8s.io\\n\\n---\\n\\napiVersion: v1\\nkind: Secret\\nmetadata:\\n  name: cicd-deploy-secret\\n  namespace: default\\n  annotations:\\n    kubernetes.io/service-account.name: cicd-deploy\\ntype: kubernetes.io/service-account-token\\n</code></pre>\\n<p>Once the service account is created, you can extract the <code>ca.cert</code> and <code>token</code>\\nparameters as mentioned for the default service account above:</p>\\n<pre><code>kubectl -n default get secret/cicd-deploy-secret -o yaml | egrep \'ca.crt:|token:\'\\n</code></pre>\\n<h2>Improvements / Ideas</h2>\\n<p>Replace the current kubectl bash script with a go implementation.</p>\\n","tags":["deploy","kubernetes","deployment","container","statefulset"],"containerImage":"euryecetelecom/woodpeckerci-kubernetes","containerImageUrl":"https://hub.docker.com/r/euryecetelecom/woodpeckerci-kubernetes","verified":false},{"name":"Dockle plugin for Woodpecker-CI","url":"https://github.com/euryecetelecom/woodpeckerci-dockle","description":"Scan containers with dockle","docs":"<h1>Dockle plugin for Woodpecker-CI</h1>\\n<p>Woodpecker-CI plugin to scan containers with dockle (Container Image Linter for Security, Helping build the Best-Practice Docker Image) <a href=\\"https://github.com/goodwithtech/dockle\\">https://github.com/goodwithtech/dockle</a>.</p>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>exit-code</code></td>\\n<td><code>1</code></td>\\n<td>If an issue is detected let the step fail</td>\\n</tr>\\n<tr>\\n<td><code>exit-level</code></td>\\n<td><code>warn</code></td>\\n<td>Define alert levels (can be info, warn or fatal)</td>\\n</tr>\\n<tr>\\n<td><code>build-directory</code></td>\\n<td><code>${CI_WORKSPACE}</code></td>\\n<td>Directory containing the Dockerfile to use to build the container</td>\\n</tr>\\n<tr>\\n<td><code>dockerfile</code></td>\\n<td><code>Dockerfile</code></td>\\n<td>Dockerfile to use</td>\\n</tr>\\n<tr>\\n<td><code>dockle-ignores</code></td>\\n<td><em>none</em></td>\\n<td>Dockle rules to ignore (cf <a href=\\"https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md\\">https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md</a>)</td>\\n</tr>\\n</tbody></table>\\n<h2>Usage</h2>\\n<p>This container require privilegied capabilities to communicate with host docker daemon, like woodpeckerci/plugin-docker-buildx. Ensure the project configuration takes it in account (verified has to be enabled).</p>\\n<h3>Simple usage:</h3>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  dockle_check:\\n    image: euryecetelecom/woodpeckerci-dockle\\n    volumes:\\n      - /var/run/docker.sock:/var/run/docker.sock\\n</code></pre>\\n<h3>Advanced usage:</h3>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  dockle_check:\\n    image: euryecetelecom/woodpeckerci-dockle\\n    volumes:\\n      - /var/run/docker.sock:/var/run/docker.sock\\n    settings:\\n      dockerfile: MyCustomDockerfile\\n      build-directory: ./docker\\n      exit-code: 0\\n      exit-level: info\\n      dockle-ignores: CIS-DI-0001,DKL-DI-0006\\n</code></pre>\\n","tags":["check","security","dockle","vulnerabilities","misconfigurations","secrets"],"containerImage":"euryecetelecom/woodpeckerci-dockle","containerImageUrl":"https://hub.docker.com/r/euryecetelecom/woodpeckerci-dockle","verified":false},{"name":"NixOS remote builder","url":"https://codeberg.org/JohnWalkerx/nix-remote-builder-plugin","icon":"https://raw.githubusercontent.com/NixOS/nixos-artwork/master/logo/nix-snowflake.svg","description":"Plugin to use the nix store of a remote system to remote build given Nix flake paths","docs":"<p><a href=\\"https://woodpecker-ci.org\\">Woodpecker CI</a> plugin which uses the store of a remote NixOS system to build our given Nix flake paths.</p>\\n<p>The usecase is that the remote system acts as a builder and Nix binarycache. So we build our NixOS systems (or packages) on the remote system and keep the output in the nix store of the remote system.</p>\\n<p>Our benefits:</p>\\n<ul>\\n<li>For each build we use the persistent store of the remote system and get much faster builds because we use already build artefacts.</li>\\n<li>The result will stay in the Nix store of the remote machine. So we can serve this store as binary cache.</li>\\n</ul>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>sshkey</td>\\n<td><em>none</em></td>\\n<td>SSH key for SSH authentification on remote system. This should be applied from a CI secret</td>\\n</tr>\\n<tr>\\n<td>username</td>\\n<td><em>none</em></td>\\n<td>Username on remote system</td>\\n</tr>\\n<tr>\\n<td>hostname</td>\\n<td><em>none</em></td>\\n<td>Hostname of remote system</td>\\n</tr>\\n<tr>\\n<td>sshport</td>\\n<td><em>none</em></td>\\n<td>SSH Port to connect on remote system</td>\\n</tr>\\n<tr>\\n<td>flakepaths</td>\\n<td><em>none</em></td>\\n<td>List of flakepaths to build separated by <code>,</code></td>\\n</tr>\\n</tbody></table>\\n<h2>Example</h2>\\n<pre><code class=\\"language-yaml\\">steps:\\n  remote-build:\\n    image: johnwalkerx/nix-remote-builder-plugin:latest\\n    pull: true\\n    settings:\\n      hostname: binarycache.example.com\\n      sshport: 22\\n      username: uploaduser\\n      sshkey:\\n        from_secret: sshkey\\n      flakepaths: &gt;-\\n        .#nixosConfigurations.machine1.config.system.build.toplevel,\\n        .#nixosConfigurations.machine2.config.system.build.toplevel\\n</code></pre>\\n<blockquote>\\n<p><strong>NOTE:</strong> Make sure to restrict usage of the secret to this specific docker image and select that only plugins can use this secrets.</p>\\n</blockquote>\\n","tags":["NixOS","build"],"containerImage":"johnwalkerx/nix-remote-builder-plugin","containerImageUrl":"https://hub.docker.com/r/johnwalkerx/nix-remote-builder-plugin","verified":false},{"name":"Release Helper","url":"https://github.com/woodpecker-ci/plugin-ready-release-go","icon":"https://woodpecker-ci.org/img/logo.svg","description":"Plugin for semi-automated releases.","docs":"<h1>Introduction</h1>\\n<p>This plugin aims to help with git-based releases.\\nIt should be run on every commit of the default branch to execute it\'s necessary actions.</p>\\n<p>A Woodpecker workflow file could look like this:</p>\\n<pre><code class=\\"language-yaml\\">steps:\\n  release-helper:\\n    image: woodpeckerci/plugin-ready-release-go\\n    settings:\\n      # release_branch: \'custom-release-branch\' # default: CI_REPO_DEFAULT_BRANCH\\n      git_email: &lt;email&gt;\\n      github_token:\\n        from_secret: GITHUB_TOKEN\\n\\nwhen:\\n  event: push\\n  branch: ${CI_REPO_DEFAULT_BRANCH}\\n</code></pre>\\n<h2>Features</h2>\\n<ul>\\n<li>Create automated changelog based on PRs which updates itself after each merge to the default branch</li>\\n<li>Auto-categorization of PRs based on labels</li>\\n<li>Automatically determines the next semver version using the PR labels</li>\\n<li>Supports any kind of programming language, changelog tool and commit style</li>\\n<li>Allows to execute custom hooks like pre, post-release</li>\\n</ul>\\n<h2>Settings</h2>\\n<p>There are two parts to configure the plugin:</p>\\n<h3>1. Most basic options can be configured via plugin settings</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>GITHUB_TOKEN</code></td>\\n<td><em>none</em></td>\\n<td>The GitHub token to use for the GitHub API</td>\\n</tr>\\n<tr>\\n<td><code>GIT_EMAIL</code></td>\\n<td><em>none</em></td>\\n<td>The email to use for git commits</td>\\n</tr>\\n<tr>\\n<td><code>RELEASE_BRANCH</code></td>\\n<td>CI_REPO_DEFAULT_BRANCH</td>\\n<td>The branch used to merge the changelog to</td>\\n</tr>\\n<tr>\\n<td><code>PULL_REQUEST_BRANCH_PREFIX</code></td>\\n<td><code>next-release/</code></td>\\n<td>The prefix used for release pull-request branches</td>\\n</tr>\\n<tr>\\n<td><code>DEBUG</code></td>\\n<td><code>false</code></td>\\n<td>Enable debug logging</td>\\n</tr>\\n</tbody></table>\\n<h3>2. Using a <code>release-config.ts</code> file in your repository</h3>\\n<p>Add a <code>release-config.ts</code> file to the root of your repository. Have a look at the <a href=\\"https://github.com/woodpecker-ci/plugin-ready-release-go/blob/main/src/utils/types.ts\\">UserConfig</a> type for all available options.</p>\\n<pre><code class=\\"language-ts\\">export default {\\n  commentOnReleasedPullRequests: false,\\n};\\n</code></pre>\\n<p>The plugin also supports executing custom hooks which can e.g. help to perform additional actions during a release (e.g. updating a helm chart\'s <code>appVersion</code> field):</p>\\n<pre><code class=\\"language-ts\\">export default {\\n  beforePrepare: async ({ exec, nextVersion }) =&gt; {\\n    await exec(`sed -i \\"s/^version:.*$/version: ${nextVersion}/g\\" Chart.yaml`);\\n  },\\n};\\n</code></pre>\\n","tags":["git","release"],"containerImage":"woodpeckerci/plugin-ready-release-go","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-ready-release-go","verified":true},{"name":"GitHub Release","url":"https://github.com/woodpecker-ci/plugin-github-release","icon":"https://woodpecker-ci.org/img/logo.svg","description":"Add files and artifacts alongside a GitHub Release.","docs":"<h1>woodpecker-github-release</h1>\\n<p>Woodpecker plugin to add files and artifacts alongside a GitHub Release.</p>\\n<h2>Settings</h2>\\n<ul>\\n<li><code>api-key</code>: API key to access Github API</li>\\n<li><code>files</code>: list of files to upload</li>\\n<li><code>file-exists</code>: what to do if file already exist (default: <code>overwrite</code>)</li>\\n<li><code>checksum</code>: generate specific checksums</li>\\n<li><code>checksum-file</code>: name used for checksum file. \\"CHECKSUM\\" is replaced with the chosen method (default: <code>CHECKSUMsum.txt</code>)</li>\\n<li><code>checksum-flatten</code>: include only the basename of the file in the checksum file</li>\\n<li><code>draft</code>: create a draft release</li>\\n<li><code>prerelease</code>: mark the release as a pre-release</li>\\n<li><code>discussion-category</code>: create a discussion in the given category</li>\\n<li><code>base-url</code>: API url, needs to be changed for GHE (default <code>https://api.github.com/</code>)</li>\\n<li><code>upload-url</code>: upload url, needs to be changed for GHE (default: <code>https://uploads.github.com/</code>)</li>\\n<li><code>title</code>: file or string for the title shown in the GitHub release</li>\\n<li><code>note</code>: file or string with notes for the release (example: changelog)</li>\\n<li><code>overwrite</code>: force overwrite existing release information, e.g. title or note</li>\\n</ul>\\n<h2>Example</h2>\\n<pre><code class=\\"language-yaml\\">steps:\\n  release:\\n    image: woodpeckerci/plugin-github-release\\n    settings:\\n      files:\\n        - dist/*.tar.gz\\n        - dist/*.deb\\n        - dist/*.rpm\\n        - dist/checksums.txt\\n      title: ${CI_COMMIT_TAG##v}\\n      api-key:\\n        from_secret: github_token\\n</code></pre>\\n","tags":["github","publish","release"],"containerImage":"woodpeckerci/plugin-github-release","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-github-release","verified":true},{"name":"Nix - Attic","url":"https://git.vdx.hu/voidcontext/woodpecker-plugin-nix-attic","description":"Plugin for building and caching nix derivations using attic","docs":"<p>This Woodpecker CI plugin is to build and cache nix derivations using the binary cache\\n<a href=\\"https://github.com/zhaofengli/attic\\">attic</a>. The image is based on NixOS.</p>\\n<h2>Features</h2>\\n<ul>\\n<li>nix experimental features enabled by default: commands and flakes</li>\\n<li>preinstalled <a href=\\"https://github.com/zhaofengli/attic\\">attic-client</a></li>\\n</ul>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>binary_cache</code></td>\\n<td><em>none</em></td>\\n<td>sets the URL of the binary cache</td>\\n</tr>\\n<tr>\\n<td><code>binary_cache_public_key</code></td>\\n<td><em>none</em></td>\\n<td>sets the public key of the binary cache</td>\\n</tr>\\n<tr>\\n<td><code>binary_cache_token</code></td>\\n<td><em>none</em></td>\\n<td>sets the access token of the binary cache</td>\\n</tr>\\n<tr>\\n<td><code>script</code></td>\\n<td><em>none</em></td>\\n<td>sets the commands / script to run</td>\\n</tr>\\n</tbody></table>\\n<h2>Example configuration</h2>\\n<pre><code class=\\"language-yaml\\">steps:\\n  check:\\n    image: git.vdx.hu/voidcontext/woodpecker-plugin-nix-attic\\n    settings:\\n      binary_cache: https://some-binary-cache.example.com\\n      binary_cache_public_key: some-binary-cache.example.com:some-public-key\\n      binary_cache_token:\\n        from_secret: binary_cache_access_token\\n      script: |\\n       nix flake check\\n       nix build\\n       attic login default $PLUGIN_BINARY_CACHE_TOKEN\\n       attic push some-cache $(nix path-info .#default)\\n</code></pre>\\n","tags":["woodpecker","nixos","nix","attic"],"containerImage":"git.vdx.hu/voidcontext/woodpecker-plugin-nix-attic","containerImageUrl":"https://git.vdx.hu/voidcontext/-/packages/container/woodpecker-plugin-nix-attic","verified":false},{"name":"Codeberg Pages Deploy","url":"https://codeberg.org/xfix/plugin-codeberg-pages-deploy","description":"Deploy project to Codeberg Pages","docs":"<h1>Codeberg Pages Deploy plugin for Woodpecker CI</h1>\\n<p>Codeberg Pages Deploy plugin automatically deploys a directory to <code>pages</code>\\nbranch.</p>\\n<h2>Usage</h2>\\n<p>To use the plugin add a step similar to this after creating a directory\\ncontaining static page contents.</p>\\n<pre><code class=\\"language-yaml\\">deploy:\\n  image: codeberg.org/xfix/plugin-codeberg-pages-deploy\\n  settings:\\n    folder: dist\\n    ssh_key:\\n      from_secret: ssh_key\\n</code></pre>\\n<p>Generate an SSH key using the following command.</p>\\n<pre><code class=\\"language-sh\\">ssh-keygen -t ed25519 -f /tmp/out\\n</code></pre>\\n<p>In Woodpecker CI settings, create a secret called <code>ssh_key</code> containing\\na private key stored in <code>/tmp/out</code> file.</p>\\n<p>In Codeberg repository settings, add a Deploy Key with Write Acccess using\\na public key stored in <code>/tmp/out.pub</code> file.</p>\\n<h2>Configuration</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Key</th>\\n<th>Information</th>\\n<th>Required</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>folder</code></td>\\n<td>Directory containing static page contents.</td>\\n<td>Yes</td>\\n</tr>\\n<tr>\\n<td><code>ssh_key</code></td>\\n<td>SSH deploy key, usually passed as a secret.</td>\\n<td>Yes</td>\\n</tr>\\n<tr>\\n<td><code>repository_name</code></td>\\n<td>Repository name to deploy to, if not specified it will deploy to the repository the workflow is running from.</td>\\n<td>No</td>\\n</tr>\\n<tr>\\n<td><code>branch</code></td>\\n<td>Branch to deploy to. Defaults to <code>pages</code>.</td>\\n<td>No</td>\\n</tr>\\n<tr>\\n<td><code>git_config_name</code></td>\\n<td>Customizes the name that is attached to the deployment commit, defaults to commit author username.</td>\\n<td>No</td>\\n</tr>\\n<tr>\\n<td><code>git_config_email</code></td>\\n<td>Customizes the email that is attached to the deployment commit, defaults to commit author email address.</td>\\n<td>No</td>\\n</tr>\\n</tbody></table>\\n","tags":["deploy","publish","codeberg"],"containerImage":"codeberg.org/xfix/plugin-codeberg-pages-deploy","containerImageUrl":"https://codeberg.org/xfix/-/packages/container/plugin-codeberg-pages-deploy/latest","verified":false},{"name":"Reviewdog golangci-lint","url":"https://codeberg.org/woodpecker-plugins/reviewdog-golangci-lint","icon":"https://woodpecker-ci.org/img/logo.svg","description":"plugin to do code review using golangci-lint using Woodpecker CI pull request builds","docs":"<p>Woodpecker CI plugin check code with golangci-lint and report results\\nas Pull Request code review using Reviewdog.</p>\\n<h2>Features</h2>\\n<ul>\\n<li>Automatically detect Forge platform and URL</li>\\n<li>Support multiple forges - Gitea, Github, Gitlab</li>\\n</ul>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>token</code></td>\\n<td><em>none</em></td>\\n<td>sets Forge API token for server</td>\\n</tr>\\n<tr>\\n<td><code>path</code></td>\\n<td><em>workspace</em></td>\\n<td>sets the working direcotry to run golangci-lint in</td>\\n</tr>\\n<tr>\\n<td><code>config</code></td>\\n<td><em>none</em></td>\\n<td>sets the custom configuration file path to use</td>\\n</tr>\\n<tr>\\n<td><code>timeout</code></td>\\n<td><code>1m</code></td>\\n<td>sets how long to wait for analysis to complete</td>\\n</tr>\\n</tbody></table>\\n<h2>Examples</h2>\\n<pre><code class=\\"language-yaml\\">  review:\\n    image: woodpeckerci/plugin-reviewdog-golangci-lint\\n    settings:\\n      token:\\n        from_secret: botuser_token\\n    when:\\n      event: pull_request\\n</code></pre>\\n","tags":["woodpecker","reviewdog","golangci-lint","pipeline"],"containerImage":"woodpeckerci/plugin-reviewdog-golangci-lint","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-reviewdog-golangci-lint","verified":true},{"name":"Reviewdog ESLint","url":"https://codeberg.org/woodpecker-plugins/reviewdog-eslint","icon":"https://woodpecker-ci.org/img/logo.svg","description":"plugin to do code review using ESLint using Woodpecker CI pull request builds","docs":"<p>Woodpecker CI plugin check code with ESLint and report results\\nas Pull Request code review using Reviewdog.</p>\\n<h2>Features</h2>\\n<ul>\\n<li>Automatically detect Forge platform and URL</li>\\n<li>Support multiple forges - Gitea, Github, Gitlab</li>\\n</ul>\\n<h2>Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>token</code></td>\\n<td><em>none</em></td>\\n<td>sets Forge API token for</td>\\n</tr>\\n<tr>\\n<td><code>path</code></td>\\n<td><em>workspace</em></td>\\n<td>sets the working direcotry to run eslint in</td>\\n</tr>\\n<tr>\\n<td><code>patterns</code></td>\\n<td><code>.</code></td>\\n<td>list of file patterns to run eslint on</td>\\n</tr>\\n<tr>\\n<td><code>extensions</code></td>\\n<td><em>none</em></td>\\n<td>list of file extensions to lint</td>\\n</tr>\\n<tr>\\n<td><code>config</code></td>\\n<td><em>none</em></td>\\n<td>sets the custom configuration file path to use</td>\\n</tr>\\n<tr>\\n<td><code>no-config</code></td>\\n<td><code>false</code></td>\\n<td>sets to not use configuation file</td>\\n</tr>\\n<tr>\\n<td><code>ignore-path</code></td>\\n<td><code>.eslintignore</code> or <code>.gitignore</code></td>\\n<td>path to pattern ignore file</td>\\n</tr>\\n<tr>\\n<td><code>ignore-patterns</code></td>\\n<td><em>none</em></td>\\n<td>list of file patterns to exclude from linting</td>\\n</tr>\\n</tbody></table>\\n<h2>Advanced settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>debug</code></td>\\n<td><code>false</code></td>\\n<td>Enable debug mode</td>\\n</tr>\\n</tbody></table>\\n<h2>Examples</h2>\\n<pre><code class=\\"language-yaml\\">  review:\\n    image: woodpeckerci/plugin-reviewdog-eslint\\n    settings:\\n      token:\\n        from_secret: botuser_token\\n    when:\\n      event: pull_request\\n</code></pre>\\n","tags":["woodpecker","reviewdog","eslint","pipeline"],"containerImage":"woodpeckerci/plugin-reviewdog-eslint","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-reviewdog-eslint","verified":true}]')}}]);